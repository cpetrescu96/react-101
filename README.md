
# TypeScript введение в типизацию

<!-- TOC -->
* [TypeScript введение в типизацию](#typescript-введение-в-типизацию)
  * [История TypeScript](#история-typescript)
  * [Установка](#установка)
  * [Транспиляция](#транспиляция)
  * [TypeScript компилятор или TSC](#typescript-компилятор-или-tsc)
  * [Что такое типы и их системы](#что-такое-типы-и-их-системы)
    * [Тип данных (type)](#тип-данных-type)
    * [Система Типов (type system)](#система-типов-type-system)
    * [Проверка типов (type checking)](#проверка-типов-type-checking)
    * [Проверка типов и доказательства](#проверка-типов-и-доказательства)
  * [Разновидности систем типов](#разновидности-систем-типов)
  * [Аннотация Типов (type annotations)](#аннотация-типов-type-annotations)
    * [Аннотация типа переменной](#аннотация-типа-переменной)
    * [Аннотация типа функции](#аннотация-типа-функции)
    * [Аннотация типа класса](#аннотация-типа-класса)
  * [Псевдонимы типов (Type Aliases)](#псевдонимы-типов-type-aliases)
  * [Вывод типа (TypeScript Определение типа)](#вывод-типа-typescript-определение-типа)
  * [Простые типы данных (Primitive types)](#простые-типы-данных-primitive-types)
    * [Тип `boolean` (логический)](#тип-boolean-логический)
    * [Числовой тип `number`](#числовой-тип-number)
    * [Тип `bigint`](#тип-bigint)
    * [Тип `string`](#тип-string)
    * [Тип `symbol`](#тип-symbol)
  * [Пустой тип - `never`](#пустой-тип---never)
  * [Возвращаемый тип `void`](#возвращаемый-тип-void)
  * [Тип `null` и значение равное `null`](#тип-null-и-значение-равное-null)
  * [Тип `undefined` и значение равное `undefined`](#тип-undefined-и-значение-равное-undefined)
  * [Тип `unknown`](#тип-unknown)
  * [Тип `any`](#тип-any)
  * [Литеральные типы](#литеральные-типы)
  * [Cсылочные типы](#cсылочные-типы)
    * [Типизация объектов](#типизация-объектов)
      * [Использование синтаксиса объектного литерала](#использование-синтаксиса-объектного-литерала)
      * [Аннотация типом `object`](#аннотация-типом-object)
      * [Объявление пустого объектного литерала ({})](#объявление-пустого-объектного-литерала-)
      * [Аннотация типом `Object`](#аннотация-типом-object-1)
      * [Сигнатура индекса `[key: T}: U`](#сигнатура-индекса-key-t-u)
      * [Структурная типизация (Structural Typing)](#структурная-типизация-structural-typing)
      * [Создание типов для объектов (Type Aliases)](#создание-типов-для-объектов-type-aliases)
      * [Опциональные свойства объектов (Optional Properties)](#опциональные-свойства-объектов-optional-properties)
      * [Объекты только для чтения](#объекты-только-для-чтения)
    * [Типизация массивов (Arrays)](#типизация-массивов-arrays)
      * [Массивы только для чтения](#массивы-только-для-чтения)
      * [Создание типов для массивов (Type Aliases)](#создание-типов-для-массивов-type-aliases)
    * [Кортежи](#кортежи)
      * [Кортежи только для чтения](#кортежи-только-для-чтения)
      * [Опциональные элементы кортежей](#опциональные-элементы-кортежей)
      * [Минимальная длина кортежей](#минимальная-длина-кортежей)
      * [Создание типов для кортежей (Type Aliases)](#создание-типов-для-кортежей-type-aliases)
    * [Типизация функций](#типизация-функций)
      * [Объявление и вызов функций](#объявление-и-вызов-функций)
      * [Параметры по умолчанию](#параметры-по-умолчанию)
      * [Опциональные параметры](#опциональные-параметры)
      * [Оставшиеся параметры (Rest parameters)](#оставшиеся-параметры-rest-parameters)
      * [Методы `call`, `apply` и `bind`](#методы-call-apply-и-bind)
  * [Перечисления Enum](#перечисления-enum)
  * [Операции над типами](#операции-над-типами)
    * [Объединение типов](#объединение-типов)
    * [Пересечение типов (Intersection Type)](#пересечение-типов-intersection-type)
  * [Классы и интерфейсы](#классы-и-интерфейсы)
    * [Общее определение класса](#общее-определение-класса)
    * [Модификаторы доступа](#модификаторы-доступа)
    * [Обращение к закрытым свойствам другого экземпляра](#обращение-к-закрытым-свойствам-другого-экземпляра)
    * [Сигнатура индекса в объявлении класса](#сигнатура-индекса-в-объявлении-класса)
    * [Классы и наследование](#классы-и-наследование)
    * [Переопределение конструктора](#переопределение-конструктора)
    * [Абстрактные классы](#абстрактные-классы)
    * [Структурная типизация классов](#структурная-типизация-классов)
    * [Статические свойства и методы класса](#статические-свойства-и-методы-класса)
    * [Тип `this`](#тип-this)
    * [Защита типа на основе this (this-based type guards)](#защита-типа-на-основе-this-this-based-type-guards)
    * [Интерфейсы](#интерфейсы)
      * [Различие между интерфейсами и псевдонимами](#различие-между-интерфейсами-и-псевдонимами)
      * [Расширение интерфейса](#расширение-интерфейса)
      * [Создание перекрестных типов (intersection types)](#создание-перекрестных-типов-intersection-types)
      * [Создание индексируемых типов (сигнатура индекса)](#создание-индексируемых-типов-сигнатура-индекса)
      * [Пример описания API JavaScript с помощью интерфейса](#пример-описания-api-javascript-с-помощью-интерфейса)
  * [Слияние деклараций](#слияние-деклараций)
  * [Сужение типов (Narrowing)](#сужение-типов-narrowing)
    * [Защита типа на основе `typeof`](#защита-типа-на-основе-typeof)
    * [Проверка истинности примитивов](#проверка-истинности-примитивов)
    * [Оператор `in` для проверки объектов](#оператор-in-для-проверки-объектов)
    * [Оператор `instanceof`](#оператор-instanceof)
    * [Защита типов на основе сравнения](#защита-типов-на-основе-сравнения)
    * [Присваивание значения (Assignments)](#присваивание-значения-assignments)
    * [Discriminated Unions](#discriminated-unions)
    * [Предикаты типов (Type predicates)](#предикаты-типов-type-predicates)
    * [Анализ потока управления](#анализ-потока-управления)
  * [Дженерики (Generic)](#дженерики-generic)
    * [Generic Type Variables (параметры типа)](#generic-type-variables-параметры-типа)
    * [Обобщённые типы (Generic Types)](#обобщённые-типы-generic-types)
    * [Ограничение типов в дженериках (Generic Constraints)](#ограничение-типов-в-дженериках-generic-constraints)
    * [Правила использования дженериков](#правила-использования-дженериков)
  * [Оператор типа Keyof](#оператор-типа-keyof)
  * [Оператор типа Typeof](#оператор-типа-typeof)
  * [Примеси (Mixin)](#примеси-mixin)
  * [Декораторы (Decorators)](#декораторы-decorators)
<!-- TOC -->

## История TypeScript

**TypeScript** был создан командой разработчиков Microsoft, ведомой Андерсом Хейлсбергом, известным своим вкладом в разработку языка программирования C#. Работа над TypeScript началась в 2010 году, а первая версия была выпущена в октябре 2012 года.

Основной целью создания TypeScript было расширение языка JavaScript, добавление статической типизации и новых возможностей, которые помогли бы разработчикам разрабатывать крупномасштабные проекты с легкостью и безопасностью.

TypeScript получил широкую популярность среди разработчиков, особенно в сообществе Angular, так как Angular использует TypeScript в качестве основного языка программирования. TypeScript также широко используется в других проектах, таких как React, Vue, Node.js и многих других.

Ключевые особенности TypeScript:

- TypeScript практически полностью совместим с JavaScript с точки зрения возможностей и типов. Всё, что есть в TypeScript, есть и в JavaScript, и наоборот. TypeScript называют надмножеством языка JavaScript. То есть это тот же JavaScript + описание типов
- Компилятор TypeScript превращает его код в код на JavaScript. То есть он удаляет определения типов из кода на TypeScript. Этот процесс еще принято называть **транспиляцией**
- Наличие строгой типизации.

[⬆ Back to Top](#typescript-введение-в-типизацию)

## Установка

Чтобы загрузить последнюю стабильную сборку через npm, используйте следующую команду:

```shell
npm install -g typescript
```

Чтобы проверить установленную версию, используйте следующую команду:

```shell
tsc -v
```
TypeScript был разработан Microsoft и доступен в VSCode по умолчанию.

[⬆ Back to Top](#typescript-введение-в-типизацию)

## Транспиляция

Транспиляция в TypeScript - это процесс преобразования кода, написанного на TypeScript, в код на JavaScript.

TypeScript - это язык программирования, который является надмножеством JavaScript и добавляет статическую типизацию и другие возможности. Однако, браузеры и серверные среды обычно поддерживают только выполнение JavaScript, поэтому перед запуском приложения на платформе, на которой необходимо использовать TypeScript, необходимо преобразовать его в эквивалентный JavaScript код. Этот процесс называется **транспиляцией**.

Транспилятор TypeScript преобразует код TypeScript в код JavaScript, который может быть выполнен на платформе, не поддерживающей TypeScript.


[⬆ Back to Top](#typescript-введение-в-типизацию)

## TypeScript компилятор или TSC

TypeScript (TS) компилятор, или TSC, является инструментом разработки, предоставляемым TypeScript.

`tsc` - это командная утилита командной строки, которая преобразует исходный код TypeScript в эквивалентный код на JavaScript. Это осуществляется путем анализа и компиляции файлов TypeScript (_.ts_) в файлы JavaScript (_.js_), которые можно запускать в любом совместимом с JavaScript окружении (браузер, сервер, Node.js и т. д.).

TypeScript компилятор также выполняет проверку типов в процессе компиляции, что позволяет предотвратить множество ошибок на раннем этапе разработки. Ошибки типизации обнаруживаются и отображаются во время компиляции, что помогает разработчикам обнаруживать и исправлять проблемы до запуска программы.

Кроме того, `tsc` предоставляет множество параметров и настроек для настройки процесса компиляции TypeScript, включая компиляцию в разные версии JavaScript (ECMAScript) и поддержку различных модульных систем.


Вот некоторые наиболее распространенные способы настройки TSC:

- Файл конфигурации: Вы можете создать файл конфигурации tsconfig.json, который содержит настройки компиляции для вашего проекта. В этом файле вы можете определить параметры, такие как target (выходная версия ECMAScript), outDir (директория, куда следует поместить скомпилированные файлы), include (список файлов для включения в компиляцию) и другие. Файл tsconfig.json должен быть расположен в корневой папке проекта.
- Командная строка: Вы можете использовать параметры командной строки для настройки TSC при выполнении компиляции. Например, вы можете указать целевую версию ECMAScript с помощью флага --target, указать директорию для выходных файлов с помощью флага --outDir и т. д.
- API компилятора: Если вы работаете с TSC из своего собственного инструмента или сценария на Node.js, вы можете использовать программный интерфейс (API) компилятора TypeScript для настройки и запуска компиляции. API позволяет изменить параметры компиляции динамически до запуска компилятора. Вы можете использовать модуль typescript в Node.js для доступа к API.
- Плагины и дополнительные инструменты: Существуют плагины и дополнительные инструменты, такие как ts-loader для Webpack, которые позволяют настраивать компиляцию TypeScript на более глубоком уровне. Эти инструменты обычно предоставляют свои собственные параметры конфигурации, которые можно использовать для настройки процесса компиляции.

Изменение настроек компиляции TSC позволяет адаптировать компилятор для конкретных требований вашего проекта. Рекомендуется ознакомиться с документацией TypeScript для получения дополнительной информации о настройке компиляции и доступных параметрах.

См. [tsconfig (typescriptlang.org)](https://www.typescriptlang.org/tsconfig)

[⬆ Back to Top](#typescript-введение-в-типизацию)

## Что такое типы и их системы

### Тип данных (type)

Тип данных в языках программирования определяет набор значений, которые может принимать переменная, а также операции, которые можно выполнять над этими значениями.
Он определяет, как компьютер должен интерпретировать и использовать данные в программе.

Тип данных определяет следующие аспекты:
- **Представление данных**: Тип данных определяет, как данные представлены в памяти компьютера. Например, целочисленные значения могут быть представлены в виде двоичного кода, чисел с плавающей точкой или символов Unicode.
- **Допустимые операции**: Тип данных определяет, какие операции могут быть выполнены над данными. Например, целочисленные типы данных поддерживают арифметические операции, такие как сложение и умножение, в то время как строковые типы данных поддерживают операции конкатенации и поиска подстроки.
- **Правила преобразования**: Тип данных определяет, какие преобразования между различными типами данных допустимы. Например, в языке программирования может быть разрешено неявное преобразование целых чисел в числа с плавающей точкой, но запрещено преобразование строковых значений в числа без явного указания.
- **Допустимый диапазон значений**: Тип данных определяет диапазон значений, которые могут быть представлены данным типом. Например, целочисленный тип данных может иметь ограничение на максимальное и минимальное значение, которое может быть представлено этим типом.

Различные языки программирования предлагают различные типы данных, такие как целые числа, числа с плавающей точкой, строки, логические значения и другие. Выбор правильного типа данных для переменных и функций в программе помогает обеспечить правильное использование и обработку данных, а также повышает безопасность и эффективность программы.

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Система Типов (type system)

Система типов в языках программирования определяет правила и ограничения для работы с типами данных. Тип данных определяет характеристики значения, такие как его диапазон значений, операции, которые можно выполнять над ним, и способы его представления в памяти компьютера.

Существует несколько типов систем типов, включая статическую типизацию, динамическую типизацию и слабую типизацию. В статически типизированных языках типы данных проверяются на этапе компиляции, в то время как в динамически типизированных языках проверка типов выполняется во время выполнения программы.

Система типов языка программирования играет важную роль в обеспечении безопасности и надежности программного кода, а также в облегчении разработки и понимания программ.

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Проверка типов (type checking)

Проверка типов - это процесс, который обеспечивает соблюдение программой правил системы типов. Она выполняется компилятором или интерпретатором языка программирования для обнаружения ошибок, связанных с неправильным использованием типов данных.

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Проверка типов и доказательства

Системы типов основаны на формальной теории. Curry-Howard correspondence (соответствие Карри-Говарда) - это связь между логикой и типами в некоторых функциональных языках программирования. Она устанавливает аналогию между доказательствами математических утверждений и программами в языках с зависимыми типами.

Согласно соответствию Карри-Говарда, типы данных могут быть рассмотрены как утверждения, а программы, имеющие эти типы, - как доказательства этих утверждений. Проверка типов в функциональных языках программирования становится аналогом проверки правильности или корректности доказательств в математике.

Таким образом, соответствие Карри-Говарда позволяет связать логическую структуру и типированную структуру, что позволяет формализовать и анализировать программы и обеспечить их корректность и безопасность.

[⬆ Back to Top](#typescript-введение-в-типизацию)

## Разновидности систем типов

Существует несколько разновидностей систем типов в языках программирования. Вот некоторые из них:

**Система типов с явной типизацией**: В этой системе типов переменные должны быть объявлены с определенным типом явно. Языки, такие как C, Java и C++, используют систему типов с явной типизацией. Преимущество этой системы заключается в том, что она обеспечивает более безопасное программирование и предотвращает неявные ошибки типов.

**Система типов с неявной типизацией**: В этой системе типы переменных выводятся автоматически компилятором, на основе контекста и значений переменных. Языки, такие как Python и JavaScript, широко используют систему типов с неявной типизацией. Это делает код более гибким и лаконичным, но может привести к неожиданным ошибкам типов.

**Сильная типизация**: Сильная типизация означает, что язык программирования не автоматически преобразует значения одного типа в другой без явного указания. В этой системе типов нельзя смешивать различные типы данных без явного преобразования. Например, в языке Java нельзя сложить строку и число без явного преобразования. Это предотвращает множество ошибок времени выполнения.

**Слабая типизация**: В слабой типизации язык программирования автоматически преобразует значения между различными типами данных без явного указания. Например, в языке JavaScript можно сложить строку и число без явного преобразования. Это удобно для быстрой разработки прототипов и простых программ, но может привести к ошибкам, которые трудно отловить.

**Статическая типизация**: Статическая типизация означает, что проверка типов выполняется на этапе компиляции. Компилятор проверяет, что переменные и функции используются с соответствующими типами данных. Примеры языков со статической типизацией включают C, Java, C++ и  TypeScript. Преимущество статической типизации заключается в том, что она может выявить ошибки типов на ранних стадиях разработки.

**Динамическая типизация (Утиная типизация)**

> Если нечто ходит как утка и крякает как утка то, значит, это утка

В этой системе типы переменных определяются и проверяются во время выполнения программы. Языки, такие как Python и JavaScript, используют динамическую типизацию. Это делает язык более гибким и удобным, но также открывает возможность для ошибок типов, которые могут возникать только во время выполнения программы.

**JavaScript** это язык с динамической типизацией, **TypeScript** со статической типизацией.

**Сравнение систем типов JavaScript и TypeScript**

|Система типов| JavaScript| TypeScript|
|-|-|-|
|Как связываются типы| Динамически| Статически|
|Конвертируются ли типы автоматически| Да| Нет (в основном)|
|Когда проверяются типы |Во время выполнения |Во время компиляции|
|Когда вскрываются ошибки| Во время выполнения (в основном)| Во время компиляции (в основном)|

[⬆ Back to Top](#typescript-введение-в-типизацию)

## Аннотация Типов (type annotations)

Аннотация типом в TypeScript используется для определения типов переменных, функций или значений.
Это способ явно указать ожидаемый тип данных, который может быть использован для проверки правильности использования переменных и функций во время компиляции.

В TypeScript аннотация типа или указание типа осуществляется с помощью оператора двоеточия `:`, после которого следует идентификатор типа данных (наименование переменной). У TypeScript строгая, статическая типизация, поэтому после того, как идентификатор будет связан с типом, изменить тип будет невозможно.

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Аннотация типа переменной

При объявлении переменных, объявляемых с помощью операторов `let` и `const` тип данных указывается сразу после идентификатора чрез двоеточие:

```ts
let num: number = 10; // Тип number
let str: string = 'Hello'; // Тип string
let bool: boolean = true; // Тип boolena
let arr1: number[] = [1, 2, 3]; // Тип Array
let arr2: Array<number> = [1, 2, 3]; // Тип Array используя синтаксис дженерика
let obj: {name: string, age: number} = {name: 'John', age: 25}; // Тип объект
```

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Аннотация типа функции

При объявлении функции, тип возвращаемого значения указывается между её параметрами и телом (или стрелкой для стрелочных функций).
При наличии параметров, тип данных указывается точно также, как и в случае аннотации переменных.

```ts
// Function declaration
function add(num1: number, num2: number): number {
  return num1 + num2;
}

// Arrow function
const greet = (name: string): void => {
  console.log('Hello ' + name);
}
```

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Аннотация типа класса

При объявлении класса для полей (Fields) класса тип указывается точно так же ка и для переменных, сразу после идентификатора через оператор двоеточия `:`.
Для методов (Methods) класса действуют те же правила указания типов данных, что и для обычных функций.

```ts
class Person {
  name: string; // Property 
  _age: number; // Property
  
  constructor(name: string, age: number) {
    this.name = name;
    this._age = age;
  }

  get age(): number { // Getter
    return this.age;
  }
  
  set age(age: number) { // Setter
    this.age = age
  }
  
  getPerson(): string { // Method
      return this.name + ' ' + this.age;
  }
}

let person: Person = new Person('John', 25);
```

Функция класс-конструктор (_constructor_) не может иметь аннотации типа возвращаемого значения - тип экземпляра класса всегда является тем, что возвращается.

Для аксессоров _get_ применяются правила аннотации функций. Для аксессора _set_ указывается лишь тип единственного параметра, а возвращаемый тип не указывается, явное указание возвращаемого типа вызовет ошибку.

[⬆ Back to Top](#typescript-введение-в-типизацию)

## Псевдонимы типов (Type Aliases)

Псевдоним типа в TypeScript - это механизм, который позволяет создавать собственные именованные типы данных для повторного использования,
на самом деле вы не создаете новый тип, а всего лишь используете псевдоним, что бы сокращенно записать определение типа для дальнейшего использования.

В среде разработчиков TypeScript принято говорить «создал тип», а не «создал псевдоним типа», это общепринятый  формат.

В TypeScript псевдонимы типов создаются с помощью ключевого слова `type`. Например, вы можете создать тип для представления строки или числа:

```ts
type MyString = string;
type MyNumber = number;
```

Теперь вы можете использовать эти type вместо прямого использования типов:

```ts
let str: MyString = 'Hello';
let num: MyNumber = 10;
```

Псевдонимы типа можно использовать для создания более сложных типов данных или объединения нескольких типов в один.
Например, вы можете создать тип для представления объекта с определенными свойствами:

```ts
type Person = {
  name: string;
  age: number;
}
```

Теперь мы можем использовать этот тип для задания типа переменной в виде аннотации типа:

```ts
let person: Person = {
  name: 'John',
  age: 25
}
```

Общепринято в TypeScript, что имена типов (Type Alias) должны быть в формате _CamelCase_ и начинаться с верхнего регистра.

Псевдонимы типов нужны для соблюдения принципа разработки **DRY** (не повторяйтесь) при работе с повторяющимися типами,
а также для прояснения задачи переменной в виде описательного имени типа для переменной.

> Когда вы решаете, нужно ли создавать тип, используйте те же доводы, что помогают решить, выделять или нет значение в отдельную переменную.


[⬆ Back to Top](#typescript-введение-в-типизацию)

## Вывод типа (TypeScript Определение типа)

**Вывод типа** - это механизм, который позволяет компилятору автоматически определить тип переменной, если тип не указан явно.

TypeScript использует алгоритм "вывода типа" для определения типов переменных на основе их значений и контекста, в котором они используются. Компилятор анализирует значение, присвоенное переменной, и типы операций, которые выполняются с этой переменной, чтобы определить наиболее подходящий тип.

Например, если переменной присваивается значение числа, TypeScript автоматически определит тип этой переменной как number. Если переменная в дальнейшем используется только для числовых операций, TypeScript будет считать, что тип этой переменной остается number.

Вот несколько примеров вывода типа в TypeScript:

```ts
// Вывод типа переменной
const name = 'John Doe'; //  Тип `name` = `string`.

// Вывод типа параметра функции
function add(a: number, b: number) { // return number
  return a + b;
} // Типом параметров `a` и `b` является `number`, а типом возвращаемого значения функции является `number`.

// Вывод типа возвращаемого значения функции
function multiply(a: number, b: number): number {
  return a * b;
}

const result = multiply(10, 20); // Тип переменной `result` = `number`.
```

- При необходимости используйте явные аннотации типов. Это может быть полезно для того, чтобы сделать ваш код более читабельным и предотвратить ошибки.
- Помните об ограничениях вывода типа. Вывод типа не всегда может правильно определить тип переменной, параметра функции или возвращаемого значения. В этих случаях вам нужно будет использовать явные аннотации типов.
- Используйте флаг компилятора `noImplicitAny: true` . Этот флаг заставит вас явно аннотировать тип всех переменных, параметров функции и возвращаемых значений. Это может помочь предотвратить ошибки и улучшить качество вашего кода.

[⬆ Back to Top](#typescript-введение-в-типизацию)

## Простые типы данных (Primitive types)

### Тип `boolean` (логический)

Булевый тип данных - это тип данных, который может принимать только два значения: true (истина) или false (ложь). Он часто используется для выражения условий, логических операций и булевых выражений.
Такие типы можно сравнивать (`==`, `===`, `||` для OR, `&&` для AND и `?`) и отрицать (`!` для NOT).

```ts
let a = true; // boolean
const b = false; // boolean, литерал типа
let c: boolean = true; // boolean
let d: true = true; // true

let e: true = false; // Ошибка TS2322: тип 'false' не может быть присвоен типу 'true'.
```

В этом примере значения для b, d представлены одним значением Boolean:

> Видишь эту переменную **b**? Она не просто какой-то там boolean, а совершенно конкретный Boolean - **true**

Тип, представляющий только одно значение и ничто другое называется **Литеральным типом**.

**Таблицы истинности AND, OR и NOT**

<table>
<tr><td><b>a</b></td><td>b</td><td>a && b</td><td>a || b</td><td>!a</td></tr>
<tr><td>true</td><td>true</td><td>true</td><td>true</td><td>false</td></tr>
<tr><td>true</td><td>false</td><td>false</td><td>true</td><td>false</td></tr>
<tr><td>false</td><td>true</td><td>false</td><td>true</td><td>true</td></tr>
<tr><td>false</td><td>false</td><td>false</td><td>false</td><td>true</td></tr>
</table>

Еще примеры использования типа `boolean`:

```ts
// Объявление булевой переменной
let isDone: boolean = false;

// Использование булевой переменной в условных выражениях
if (isDone) {
  console.log('Работа завершена');
} else {
  console.log('Работа не завершена');
}

// Логические операции с булевыми переменными
let isLogged: boolean = true;
let hasPermission: boolean = false;

if (isLogged && !hasPermission) {
  console.log('Недостаточно прав для доступа');
}

// Возвращение булевого значения из функции
function isEven(num: number): boolean {
  return num % 2 === 0;
}

console.log(isEven(4)); // Выведет: true
console.log(isEven(3)); // Выведет: false
```

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Числовой тип `number`

Тип `number` в TypeScript используется для представления числовых значений, включая как целые, так и дробные числа. Этот тип данных используется для определения переменных, которые могут содержать числовые значения.

Операции, которые могут быть применимы к типу `number`:

- Арифметические операции: сложение (+), вычитание (-), умножение (*), деление (/), остаток от деления (%).
  ```ts
  let a: number = 10;
  let b: number = 5;
  let sum: number = a + b; // Результат: 15
  let difference: number = a - b; // Результат: 5
  let product: number = a * b; // Результат: 50
  let quotient: number = a / b; // Результат: 2
  let remainder: number = a % b; // Результат: 0
  ```
- Сравнение: равенство (==), неравенство (!=), строгое равенство (===), строгое неравенство (!==), больше (>), меньше (<), больше или равно (>=), меньше или равно (<=).
  ```ts
  let x: number = 10;
  let y: number = 20;
  let isEqual: boolean = x === y; // Результат: false
  let isGreaterThan: boolean = x > y; // Результат: false
  let isLessThan: boolean = x < y; // Результат: true
  ```
- Инкремент и декремент: увеличение на 1 (++) и уменьшение на 1 (--).
  ```ts
  let count: number = 5;
  count++; // count увеличивается на 1 (Результат: 6)
  count--; // count уменьшается на 1 (Результат: 5)
  ```
- Побитовые операторы: побитовое И (&), побитовое ИЛИ (|), побитовое исключающее ИЛИ (^), побитовый сдвиг влево (<<), побитовый сдвиг вправо (>>), беззнаковый побитовый сдвиг вправо (>>>) и т.д (см. [Побитовые операторы](https://learn.javascript.ru/bitwise-operators)).
  ```ts
  let x:number = 5; // двоичное представление 101
  let y:number = 3; // двоичное представление 011
  
  let result1:number = x & y;  // побитовое И, результат 001 (1 в десятичной системе)
  let result2:number = x | y;  // побитовое ИЛИ, результат 111 (7 в десятичной системе)
  let result3:number = x ^ y;  // побитовое исключающее ИЛИ, результат 110 (6 в десятичной системе)
  let result4:number = x << 1; // побитовый сдвиг влево на 1 позицию, результат 1010 (10 в десятичной системе)
  let result5:number = x >> 1; // побитовый сдвиг вправо на 1 позицию, результат 10 (2 в десятичной системе)
  let result6:number = x >>> 1; // беззнаковый побитовый сдвиг вправо на 1 позицию, результат 10 (2 в десятичной системе)
  ```

Также к числовым значениям можно применять различные математические функции и операции, такие как возведение в степень, вычисление квадратного корня, округление числа и т. д.

Для длинных чисел можно использовать десятичный разделитель как в значениях, так и в типах для их удобного чтения:

```ts
let oneMillion = 1_000_000; // Эквивалент 1000000
let twoMillion: 2_000_000 = 2_000_000;
```

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Тип `bigint`

Тип `bigint` используется для представления целых чисел произвольной точности, в отличие от типа `number`, который представляет ограниченный диапазон целых чисел.

Тип `bigint` был добавлен в стандарт ECMAScript 2020 и позволяет работать с очень большими числами.
В отличие от чисел типа `number`, значения типа `bigint` оканчиваются на "n" (например, const bigNum: bigint = 123456789012345678901234567890n;).

```ts
let a = 1234n; // bigint
const b = 5678n; // 5678n
const c = a + b; // bigint
let d = a < 1235; // boolean

let e = 88.5n; // Ошибка TS1353: литерал bigint
               // должен быть целым числом.

let f: bigint = 100n; // bigint
let g: 100n = 100n; // 100n

let h: bigint = 100; // Ошибка TS2322: тип '100' 
                     // не может быть присвоен типу 'bigint'
```

Тип `bigint` полезен при работе с большими целыми числами, такими как применение криптографических алгоритмов, обработка больших идентификаторов и т. д.

См. [BigInt](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/BigInt)

Пример создание типа для числовых значений:

```ts
type MyNumber = number; 
```

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Тип `string`

Тип string является набором всех строк и доступных для них операций вроде конкатенации (+), среза (.slice) и т. д.

```ts
let a = 'hello' // string
const b = 'billy' // string
const c = '!' // '!'
let d = a + ' ' + b + c // string
let e: string = 'zoom' // string 
let f: 'john' = 'john' // 'john'

let g: 'john' = 'zoe'   // Ошибка TS2322: тип "zoe" 
                        // не может быть присвоен типу "john".
```

Пример создание типа для строковых значений:

```ts
type MyString = string;
```

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Тип `symbol`

Тип `symbol` появился с одной из последних ревизий JavaScript (ES2015).
На практике символы встречаются нечасто.

Тип `symbol` используется для представления уникальных идентификаторов. Каждый символ создается с помощью функции `Symbol()` и представляет собой уникальное значение.

```ts
let a = Symbol('a'); // symbol
let b: symbol = Symbol('b'); // symbol
const c = a === b; // boolean

let d = a + 'x'; // Ошибка TS2469: оператор '+' не может
                 // быть применен к типу 'symbol'.
const e = Symbol('e') // typeof e
const f: unique symbol = Symbol('f'); // typeof f

let g: unique symbol = Symbol('f'); // Ошибка TS1332: переменная,
                                   // имеющая тип 'unique symbol',
                                   // должна быть 'const'.
let h = e === e; // boolean

let i = e === f; // Ошибка TS2367: это условие всегда будет
                 // возвращать 'false', поскольку типы 'unique
                 // symbol' и 'unique symbol' не имеют сходства
```

Особенности создания уникального символа c использованием `const`:

- При объявлении переменной с `const`, TypeScript выводит ее тип как `unique symbol`.
- В редакторе кода она будет отображаться не как `unique symbol`, а как `typeof _имяПеременной_`.
- `unique symbol` всегда равен самому себе.
- `unique symbol` никогда не будет равен никакому другому `unique symbol`

Тип `symbol` часто используется для создания уникальных ключей в объектах, например, когда требуется создать "скрытые" свойства, которые не будут конфликтовать с другими свойствами объекта. Также символы могут быть использованы для определения специальных методов или свойств объекта, которые не должны быть случайно переопределены.

Тип `symbol` также может быть использован в качестве ключей для словарей или Map, обеспечивая уникальность ключей и предотвращая переопределение значений.

[⬆ Back to Top](#typescript-введение-в-типизацию)

## Пустой тип - `never`

Этот тип данных называется "необитаемым" (uninhabitable type), или пустым типом данных (empty type), потому что создать его экземпляр невозможно.
Он используется для обозначения ситуаций, когда функция никогда не завершается или когда никакое значение не может быть присвоено переменной.

```ts
function throwError(message: string): never {
  throw new Error(message);
}
```

В этом примере тип возвращаемого значения функции указан как `never`, потому что функция всегда вызывает ошибку и никогда не завершается нормально.

Если попытаться присвоить результат вызова этой функции переменной, то TypeScript будет понимать, что эта переменная также имеет тип never, так как она никогда не будет иметь значение.

```ts
const result:never  = throwError('Something went wrong');
```

Тип `never` используется везде, где встречаются не возвращающие ничего функции, либо где требуется указать явным образом, что никакого значения нет.

[⬆ Back to Top](#typescript-введение-в-типизацию)

## Возвращаемый тип `void`

В TypeScript тип void используется для указания, что функция не возвращает никакого значения. Он применяется, когда функция не имеет оператора return или имеет оператор return без какого-либо значения. Тип void также может быть использован для явного указания типа переменной, которая не имеет значения. Использование типа void заставляет компилятор TypeScript проверять, чтобы функция не возвращала никакого значения, и генерировать ошибку компиляции, если это условие нарушено.

```ts
function greet (): void {
  console.log('Hello world!');
}
```

Данная функция выводит в консоль приветствие и ничего не возвращает.

Оператор `return` без какого-либо значения так же будет указывать на возвращаемое значение типа `void`;

```ts
function greet (): void {
  console.log('Hello world!');
  
  return;
}
```

Тип `void` относится к единичному типу (unit type), также известному как тип-заглушка или тип-единица, он представляет собой тип данных в языках программирования, который имеет только одно возможное значение. Обычно это представлено значением, которое не несет никакой информации и не имеет смысловой нагрузки.

> Функции, которые могут принимать некоторое число аргументов, но не возвращающие никакого значения, называются действиями (actions).

[⬆ Back to Top](#typescript-введение-в-типизацию)

## Тип `null` и значение равное `null`

В TypeScript тип `null` представляет собой тип данных, который имеет только одно возможное значение - `null`.
Это означает, что переменная, объявленная с типом `null`, может содержать только значение `null`.

Вот как можно объявить переменную с типом null:

```ts
const a: null = null;
```

Тип `null` используется для указания, что переменная может содержать значение `null`, т.е. отсутствие значения.
Например, если у вас есть переменная, которая может содержать информацию о чем-то, но в каких-то случаях это информация отсутствует, вы можете объявить переменную с типом включающим `null`.

Теперь давайте перейдем к разнице между типом `null` и его значением.
В TypeScript тип `null` определяет набор возможных значений - в данном случае, это только `null`.
С другой стороны, значение `null` представляет собой фактическое отсутствие значения в переменной.

Таким образом, тип `null` определяет, что переменная может содержать только значение `null`, в то время как само значение `null` представляет отсутствие какого-либо значения.

Например:

```ts
let obj: null; // Определяем, что obj может содержать только значение null
obj = null; // Присваиваем переменной значение null (отсутствие значения)
```

Важно понимать разницу между типом `null` и его значением, чтобы использовать их правильно при разработке программ.

[⬆ Back to Top](#typescript-введение-в-типизацию)

## Тип `undefined` и значение равное `undefined`

Тип `undefined` - это тип, который представляет значение `undefined`. Он используется, когда вы хотите указать, что переменная может быть как определена, так и неопределена (нулевая безопасность).

Разница между типом и значением заключается в следующем:

- Тип `undefined` - это тип данных и используется для аннотирования переменных и функций.
- Значение `undefined` - это фактическое значение, которое может быть присвоено переменной. Когда переменная не имеет значения, ей присваивается значение `undefined`.

В TypeScript можно явно указать тип `undefined` для переменных, используя оператор объединение типа `|`, например:

```ts
let x: number | undefined;
console.log(x); // undefined

x = 23;
console.log(x); // 23
```

В этом примере, переменная `x` может быть типа `number` или `undefined`.

[⬆ Back to Top](#typescript-введение-в-типизацию)

## Тип `unknown`

Тип `unknown` используется для переменных, значение которых может быть неизвестным на момент компиляции. Этот тип представляет собой безопасное дополнение к типу `any`.

`unknown` тип позволяет проверять тип переменных перед выполнением определенных операций, чтобы избежать ошибок времени выполнения.
В отличие от типа `any`, `unknown` требует явного проверки типов перед его использованием.

Для использования типа `unknown` в TypeScript, можно объявить переменную с этим типом следующим образом:

```ts
let value: unknown;

console.log(value); // undefined
```

Когда переменная имеет тип `unknown`, она не может быть использована напрямую. Для использования ее значения, необходимо явно проверить ее тип и привести к соответствующему типу.

```ts
const greet = () => `Hello, World!`;

value = greet(); // Присваивает строку

if (typeof value === `string`) { // Теперь это строка
  let strLength: number = value.length;

  console.log(strLength); // 13
}
```

Использование типа `unknown` в TypeScript позволяет более безопасно работать с неизвестными значениями, обеспечивая проверку типов перед их использованием и предотвращая ошибки времени выполнения.

[⬆ Back to Top](#typescript-введение-в-типизацию)

## Тип `any`

В TypeScript `any` представляет любой тип.  Если вы определите переменной тип any, вы сможете присвоить ей что угодно и делать с ней что угодно.

Использование типа `any` отключает проверку типов, что крайне не рекомендуется делать.
Если включен строгий режим с помощью `"strict": true` в _tsconfig.json_, то использование `any` становится невозможным.

Вместо использования типа `any` в TypeScript, рекомендуется использовать явное указание типов или более конкретные типы данных, такие как `number`, `string`, `boolean` и др., чтобы получить все преимущества статической типизации этого языка.
Если тип данных неизвестен или не может быть точно определен, рекомендуется использовать тип `unknown`, который обеспечивает безопасности типов на этапе компиляции.

[⬆ Back to Top](#typescript-введение-в-типизацию)

## Литеральные типы

Литерал типа в TypeScript представляет собой конкретное значение, которое может быть использовано в качестве типа данных. Например, литерал типа может быть использован для ограничения возможных значений переменной, функции или параметра на определенное значение.

Литералы типов позволяют более точно определять и ограничивать возможные значения переменных и параметров функций в TypeScript.

Пример использования литералов типов в TypeScript:

```ts
// Литерал типа для ограничения возможных значений переменной
let direction: 'left' | 'right' | 'up' | 'down';
direction = 'up'; // Верно
direction = 'diagonal'; // Ошибка, так как "diagonal" не является допустимым значением

// Литерал типа для определения возможных значений параметра функции
function printText(text: string, alignment: 'left' | 'center' | 'right') {
    // ...
}

printText('Hello, world!', 'center'); // Верно
printText('Hello, world!', 'top'); // Ошибка, так как "top" не является допустимым значением
```

[⬆ Back to Top](#typescript-введение-в-типизацию)

## Cсылочные типы

В TypeScript, как и в JavaScript, ссылочные типы представляют собой типы данных, значения которых передаются по ссылке, а не по значению.
Когда вы присваиваете переменной ссылочный тип, она содержит ссылку на место в памяти, где хранится фактическое значение.
Это отличается от примитивных типов, таких как `number`, `string`, `boolean`, которые передаются по значению.

В TypeScript существуют несколько встроенных ссылочных типов:

- **Объекты (Objects)**: Объекты в TypeScript представляют собой экземпляры классов или литеральные объекты, и они являются ссылочными типами. При присвоении объектной переменной передается ссылка на место в памяти, где хранится сам объект.

  ```ts
  const obj1 = { name: 'John' };
  
  // obj2 ссылается на ту же область памяти, что и obj1
  const obj2 = obj1; 
  
  obj1.name = 'Alice';
  
  // Выведет 'Alice', так как изменение obj1 отразится на obj2
  console.log(obj2.name); 
  ```
- **Массивы (Arrays)**: Массивы в TypeScript также являются ссылочными типами. При присваивании массива переменной также передается ссылка на место в памяти, где хранятся элементы массива.
  ```ts
  const arr1: number[] = [1, 2, 3];
  
  // arr2 ссылается на ту же область памяти, что и arr1
  const arr2: number[] = arr1;
  
  arr1[0] = 0;
  
  // Выведет 0, так как изменение arr1 отразится на arr2
  console.log(arr2[0]); 
  ```
- Функции (Functions): Функции в TypeScript также являются ссылочными типами. Когда вы присваиваете функцию переменной или передаете ее в качестве аргумента, передается ссылка на код функции.
  ```ts
  function greet(name: string): string {
    console.log(`Hello, ${name}!`);
  }
  
  // myGreet ссылается на ту же область памяти, что и greet
  const myGreet = greet;
  
  // Вызовет функцию greet и выведет 'Hello, John!' 
  myGreet('John'); 
  ```

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Типизация объектов

Тип `object` в TypeScript определяет форму объекта.

В TypeScript есть несколько способов использования типов для описания объектов:

- Использование синтаксиса объектного литерала.
- Аннотация типом `object`.
- Аннотация пустым объектным литералом ({}). Старайтесь его избегать.
- Аннотация типом `Object`. Старайтесь его избегать.

Таблица соответствия допустимых значений для объектов:

| Значение        | {}   | object | Object |
|-----------------|------|--------|--------|
| {}              | Да   | Да     | Да     |
| ['a']           | Да   | Да     | Да     |
| function () {}  | Да   | Да     | Да     |
| new String('a') | Да   | Да     | Да     |
| 'a'             | Да   | Нет    | Да     |
| 1               | Да   | Нет    | Да     |
| Symbol('a')     | Да   | Нет    | Да     |
| true            | Да   | Нет    | Нет    |
| false           | Да   | Нет    | Нет    |
| `null`          | Нет  | Нет    | Нет    |
| `undefined`     | Нет  | Нет    | Нет    |

#### Использование синтаксиса объектного литерала

> Литерал объекта - это список из нуля или более пар, состоящих из имён свойств и связанных с ними значений, заключённый в фигурные скобки `{}`.

Синтаксис объектного литерала сообщает: «Здесь находится объект такой формы (структуры)».
Этот объект может быть либо объектным литералом, либо экземпляром класса.

```ts
// Объявление объектного литерала с аннотацией типа
let user: {
  firstName: string;
  lastName: string;
} = {
  firstName: 'John',
  lastName: 'Barrowman'
}
  
// Объявление объектного литерала без аннотации типа
let user2 = {
  firstName: 'John',
  lastName: 'Barrowman'
}

// Объявление класса
class Person {
  constructor(
    // public является сокращением this.firstName = firstName
    public firstName: string,
    public lastName: string
  ) {}
  
  getFullName(): string {
      return this.firstName + ' ' + this.lastName;
  }
}

// Присваивание нового объекта
user = user2; // OK - Структура совпадает
user = new Person('matt', 'smith') // OK
```

Здесь `{ firstName: string, lastName: string }` является сигнатурой объектного литерала и описывает форму объекта.

Объектный литерал и экземпляр класса (структура полей класса) соответствуют этой форме, поэтому TypeScript позволяет присвоить `Person` литералу `user`, на этом этапе TypeScript автоматически отслеживает совместимость структур, этот механизм вызывается [**Структурной типизацией**](#структурная-типизация-structural-typing).

[⬆ Back to Top](#typescript-введение-в-типизацию)

#### Аннотация типом `object`

Пример использования аннотации с типом `object` в TypeScript:

```ts
// Объявление объектного литерала с аннотацией типа object
let user: object = {
  firstName: 'John',
  lastName: 'Barrowman'
}

console.log(user.firstName);
// Ошибка: Property 'firstName' does not exist on type 'object'. (TS2339)
````

Обращение к `firstName` не будет работать, так как `object` не является сигнатурой объектного литерала.

Тип `object` в данном примере соответствует типу `any`, этот тип сообщает вам, что значение является объектом JavaScript (и оно не `null`).

Одним из примеров использования аннотации с типом object в TypeScript может быть создание функции, которая принимает объект в качестве параметра:

```ts
function logObject(obj: object) {
  console.log(obj);
}

const user = {
    name: 'John',
    age: 30
};

logObject(user);
```

В данном примере функция `logObject` принимает объект `obj` с типом `object`. Это означает, что в функцию можно передавать объекты любого типа, так как все объекты в TypeScript наследуются от типа `object`.

В реальной жизни старайтесь избегать аннотации типа `object`, отдавайте предпочтение использованию сигнатуры объектного литерала с описанием типов полей объекта в качестве аннотации типа.

Альтернативой для создания функций с использованием разных типов являются дженерики (generics).

[⬆ Back to Top](#typescript-введение-в-типизацию)

#### Объявление пустого объектного литерала ({})

Рассмотрим пример объявления пустого объектного литерала:

```ts
let danger: {};

danger = {}
danger = {x: 1}
danger = []
danger = 2
```

В этом примере `danger` является пустым объектным литералом и имеет тип пустого объекта ({}), это означает, что ему можно присвоить любое значение за исключением `null` и `undefined`.

Как и в случае с типом `any` и `object`, старайтесь избегать использования пустого объектного литерала.

[⬆ Back to Top](#typescript-введение-в-типизацию)

#### Аннотация типом `Object`

Тип `Object` - это практически то же самое, что использование пустого объектного литерала ({}), как и в пред идущем случае рекомендуется избегать его использование.

```ts
let danger: Object;

danger = {}
danger = {x: 1}
danger = []
danger = 2
```

[⬆ Back to Top](#typescript-введение-в-типизацию)

#### Сигнатура индекса `[key: T}: U`

Синтаксис `[key: T}: U` называется сигнатурой индекса.
Она позволяет указать типы значений для набора ключей, которые неизвестны заранее.

Синтаксис сигнатуры индекса следующий:

```ts
{
  [keyName: keyType]: valueType;
}
```

- `keyName` - имя ключа, который может быть числовым или строковым, это может быть любое слово, включая `key`.
- `keyType` - тип индекса, который может быть `number` (для числового индекса) или `string` (для строкового индекса).
- `valueType` - тип значения, которое будет доступно по индексу.

Давайте рассмотрим пример использования сигнатуры индекса:

```ts
// Создание типа Dictionary при помощи ключевого слова type
type Dictionary = {
  [key: string]: string;
}

const colors: Dictionary = {
  red: 'FF0000',
  green: '00FF00',
  blue: '0000FF'
};

console.log(colors['red']); // Выведет: FF0000
console.log(colors['green']); // Выведет: 00FF00
```

В этом примере создается тип (type) `Dictionary`, который определяет тип объекта с индексированным доступом по строковым ключам. Мы указываем, что каждое значение, доступное по индексу, будет иметь тип `string`.

Затем создается объект `colors`, который аннотирован типом `Dictionary` и теперь можно использовать строковые ключи (например, 'red', 'green', 'blue') для доступа к соответствующим значениям в объекте `colors`.

Сигнатура индекса позволяет нам работать с объектами, у которых заранее неизвестные ключи, но имеющие один и тот же тип значения. Это может быть полезно для работы с динамическими данными, например, в случае парсинга JSON-объектов, где ключи могут быть различными, но значения имеют одинаковый тип.

[⬆ Back to Top](#typescript-введение-в-типизацию)

#### Структурная типизация (Structural Typing)

Структурная типизация (Structural Typing) - это концепция типизации, которая основывается на структуре и форме объектов, а не на их явно определенных типах. В контексте TypeScript это означает, что два объекта совместимы в типизации, если их структуры совпадают, независимо от того, явно ли определены типы этих объектов или нет.

Давайте рассмотрим пример структурной типизации в TypeScript:

```ts
// Создание типа Person при помощи ключевого слова type
type Person = {
  name: string;
  age: number;
}

function greet(person: Person): void {
  console.log(`Hello, ${person.name}!`);
}

const john = { name: 'John', age: 25 };
const alice = { name: 'Alice', age: 30 };

greet(john); // Выведет: Hello, John!
greet(alice); // Выведет: Hello, Alice!
```

В примере выше у нас есть тип (type) `Person`, который определяет структуру объекта с двумя полями: name типа string и age типа number. Затем у нас есть функция `greet`, которая принимает объект типа `Person` и выводит приветствие с именем этого человека.

Мы создаем два объекта `john` и `alice`, которые имеют ту же структуру, что и `Person`. Хотя эти объекты явно не определены как `Person`, они по-прежнему могут передаваться в качестве аргумента в функцию `greet`, потому что их структуры совпадают с ожидаемой структурой `Person`. TypeScript автоматически отслеживает совместимость структур и позволяет нам использовать их вместо явно заданных типов.

В результате примера получается ожидаемый вывод, и функция `greet` работает с объектами, имеющими нужную структуру, независимо от типов, с которыми они были созданы.

Структурная типизация позволяет более гибко работать с типами данных в TypeScript и, например, делать использование библиотек, которые не определяют явные типы или имеют различные именования типов. Однако она также требует внимательности, так как типы могут быть не явными, и некоторые возможные ошибки могут быть не заметны на этапе компиляции.

[⬆ Back to Top](#typescript-введение-в-типизацию)

#### Создание типов для объектов (Type Aliases)

Для создания типа указывающего на объект используется ключевое слово `type`, cинтаксис создания типа выглядит следующим образом:

```ts
type TypeName = {
  property1: Type1;
  property2: Type2;
  // ...
};
```

Где `TypeName` - это имя псевдонима типа, а `property1`, `property2`, и т.д. - это свойства объекта, а также их типы `Type1`, `Type2`, и т.д.
В качестве типов `Type1`, `Type2` могут выступать любые встроенные типы, а так же типы определенные с помощью `type` или `interface`.

Пример использования:

```ts
type Person = {
  name: string;
  age: number;
  isStudent: boolean;
};

const john: Person = {
  name: 'John',
  age: 25,
  isStudent: true
};
```

[⬆ Back to Top](#typescript-введение-в-типизацию)

#### Опциональные свойства объектов (Optional Properties)

В TypeScript предусмотрены опциональные свойства объектов, которые позволяют объявлять некоторые свойства объекта как необязательные для заполнения.

Опциональные свойства объявляются с использованием символа вопросительного знака (`?`) после имени свойства в объявлении объекта:

```ts
type Person = {
  name: string;
  age?: number; // 'number | undefined'
};
```

В этом примере свойство "age" объявлено как опциональное. Это означает, что объекты, соответствующие интерфейсу MyObject, могут иметь свойство "age", но оно может быть не определено.

```ts
const person1: Person = { name: 'John' }; // OK
const person2: Person = { name: 'Alice', age: 25 }; // OK
const person3: Person = { name: 'Bob', age: undefined }; // OK

const person4: Person = { name: 'Kate', age: null }; // Ошибка: Type 'null' is not assignable to type 'number | undefined'
```

Кроме того, можно объявить тип с опциональными свойствами, используя утилиту `Partial<Type>`.
Утилита `Partial<Type>` делает все свойства необязательными.

```ts
type MyObject = {
  name: string;
  age: number;
}

const obj: Partial<MyObject> = {}; // Все свойства стали опциональными
```

[⬆ Back to Top](#typescript-введение-в-типизацию)

#### Объекты только для чтения

В TypeScript существуют объекты только для чтения, вы можете создавать объекты, свойства которых могут быть только для чтения.

Для этого используется ключевое слово `const`, утилита `Readonly<Type>` или модификатор `readonly` для свойств объекта.

Пример литерала объекта с ключевым словом `const`:

```ts
const person = {
  name: 'John',
  age: 25
} as const; // { readonly name: 'John', readonly age: 25 }
```

Использование утилиты `Readonly<Type>` выглядит следующим образом:

```ts
type Person = Readonly<{
  name: string;
  age: number;
}>;

const person: Person = {
  name: 'John',
  age: 25
}

person.name = 'Alice'; // Ошибка: Cannot assign to 'name' because it is a read-only property
```

Пример использования модификатора `readonly`:

```ts
type Person = {
  readonly name: string;
  readonly age: number;
};

const person: Person = {
  name: 'John',
  age: 25
}

person.name = 'Alice'; // Ошибка: Cannot assign to 'name' because it is a read-only property
```

Пример использования типа который изначально не определен как "только для чтения":

```ts
// Тип Person не определен как "только для чтения"
type Person = {
  name: string;
  age: number;
};

// Использование Readonly<Type>
const person1: Readonly<Person> = {
  name: 'John',
  age: 25
}
````

Конструкция `as const` с аннотацией типа в объявлении переменной работать не будет:

```ts
const person1: Person = {
  name: 'John',
  age: 25
} as const; // Работать не будет

// Использование оператора satisfies с типом Person
const person2 = {
  name: 'John',
  age: 25
} as const satisfies Person; // OK
```

Оператор `satisfies` в TypeScript (начиная с 4.9) используется для проверки, удовлетворяет ли тип определенные требования. Он используется в контексте типов для проверки соответствия конкретного типа набору свойств или методов. Это позволяет более точно определять, соответствует ли заданный тип определенным критериям.

См. [satisfies](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#the-satisfies-operator)

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Типизация массивов (Arrays)

В TypeScript, как и в JavaScript (4.9), массивы являются особыми объектами, поддерживающими конкатенацию, передачу, поиск и срезы.

TypeScript поддерживает два варианта синтаксиса для массивов: с использованием `[]` и с использованием `Array`

Примеры с типизацией массива:

```ts
// Неявное определение типа массива
const a = [1, 2, 3] // number[]
const b = ['a', 'b'] // string[]

// Явное определение типа массива через аннотацию типа
const c: string[] = ['a'] // string[]
const d: Array<number> = [1, 2, 3] // number[]

// Смешанный массив - рекомендуется избегать
const e = [1, 'a'] // (string | number)[]
```

В последней строке примера показан неоднородный массив, потому что в нем содержатся элементы разных типов, на этот счет в TypeScript существует правило:

- Массив в TypeScript должен быть однородным, потому что TypeScript - это язык со строгой типизацией. Это означает, что каждая переменная и элемент массива должны иметь один и тот же тип данных.

Однородность массива позволяет:
- Обеспечить безопасность типов, что повышает надежность кода;
- Упростить чтение и понимание кода, поскольку тип данных массива известен заранее;
- Сделать код более поддерживаемым и расширяемым, так как легче добавить, изменить или удалить элементы массива с однородными типами данных;
- Улучшить производительность, так как компилятор TypeScript может применять оптимизации, основанные на предположении о однородности типов данных.

[⬆ Back to Top](#typescript-введение-в-типизацию)

#### Массивы только для чтения

В TypeScript существуют массивы только для чтения, вы можете определить массив, элементы которого нельзя изменять после его создания.
Это полезный инструмент для обеспечения иммутабельности данных и предотвращения неожиданных изменений в массиве.

Чтобы создать массив только для чтения, можно использовать тип `ReadonlyArray<T>` или его короткую форму `readonly T[]`, где `T` - это тип элементов массива.

Дополнительно в TypeScript существует утилита для манипуляции с типами `Readonly<T>`, где `T` - это тип элементов массива, см. [Readonly (typescriptlang.org)](https://www.typescriptlang.org/docs/handbook/utility-types.html#readonlytype).

Вот пример:

```ts
const numbers: readonly number[] = [1, 2, 3, 4]; // readonly number[]
// или
const prices: ReadonlyArray<number> = [45.99, 34.99, 78.99]; // readonly number[]
const contents: Readonly<string[]> = ['a', 'b', 'c']; // readonly string[]
```

В данном примере создается массив `numbers`, содержащий числа от 1 до 4. Тип `readonly number[]` указывает, что этот массив только для чтения, и его элементы не могут быть изменены.

С использованием массивов только для чтения, вы можете выполнить операции чтения элементов массива, такие как доступ к элементу по индексу или итерация по массиву:

```ts
const numbers: readonly number[] = [1, 2, 3, 4];

console.log(numbers[0]);  // Вывод: 1

for (const num of numbers) {
    console.log(num);  // Выводит числа от 1 до 4
}
```

Однако, попытка изменить элемент массива приведет к ошибке:
```ts
const numbers: readonly number[] = [1, 2, 3, 4];

numbers[0] = 10; // Ошибка: Нельзя присвоить 
                 // новое значение элементу массива только для чтения
```

Массивы только для чтения особенно полезны в ситуациях, когда требуется гарантировать, что данные не будут изменены в процессе выполнения программы. Они также могут быть использованы для передачи данных между различными частями программы, предотвращая их изменение.

Важно отметить, что массивы только для чтения не гарантируют, что элементы массива также будут неизменными. Если элементы массива имеют ссылочный тип, их свойства могут быть изменены, несмотря на режим только для чтения самого массива.

[⬆ Back to Top](#typescript-введение-в-типизацию)

#### Создание типов для массивов (Type Aliases)

Есть два основных способа создания типов массивов:

- Использование квадратных скобок: вы можете указать тип элементов массива в квадратных скобках после объявления переменной. Например, для объявления массива чисел вы можете использовать следующий синтаксис:
  ```ts
  type MyNumbers = number[];
  
  const numbers: MyNumbers = [1, 2, 3, 4, 5];
  ```
- Использование обобщенного типа `Array<Type>`: вы также можете использовать обобщенный тип `Array` для создания типов массивов. Например, для объявления массива строк вы можете использовать следующий синтаксис:
  ```ts
  type Names = Array<string>;
  
  const names: Names =  ['Alex', 'Diana', 'Charlie'];
  ```

Оба способа эквивалентны и могут использоваться в зависимости от вашего предпочтения.


[⬆ Back to Top](#typescript-введение-в-типизацию)

### Кортежи

Кортежи являются подтипами массивов. Они позволяют типизировать массивы фиксированной длины, в которых значения каждого индекса имеют конкретные известные типы.

Кортежи всегда должны типизироваться явно.

```ts
let a: [number] = [1]

// Кортеж [имя, фамилия, год рождения]
let b: [string, string, number] = ['John', 'Doe', 2002];

b = [2002, 'Doe', 'John']; // Ошибка: Type 'number' is not assignable to type 'string'.
```

[⬆ Back to Top](#typescript-введение-в-типизацию)

#### Кортежи только для чтения

Как и в случае с массивами, кортежи то же могут быть только для чтения, для обозначения кортежа только для чтения используется тип `readonly` или утилиту `Readonly<T>`, где `T` - это тип элементов кортежа:

```ts
const tupleA: readonly [string, string, number] = ['John', 'Doe', 2002];
const tupleB: Readonly<[string, string, number]> = ['John', 'Doe', 2002];
```

[⬆ Back to Top](#typescript-введение-в-типизацию)

#### Опциональные элементы кортежей

Кортежи также поддерживают опциональные элементы. Как и для типов `object`, необязательные элементы обозначается знаком `?`:

```ts
const tupleA: [string, string, number?] = ['John', 'Doe', 2002]; // [string, string, (number | undefined)?]
const tupleB: [string, string, number?][] = [ // [string, string, (number | undefined)?][]
    ['John', 'Doe', 2002],
    ['Albert', 'Einstein']
];
```

[⬆ Back to Top](#typescript-введение-в-типизацию)

#### Минимальная длина кортежей

Кортежи также поддерживают оставшиеся элементы, которые вы можете использовать для типизации кортежей с минимальной длинной:

```ts
// Список строк с как минимум одним элементом
let friends: [string, ...string[]] = ['Alex', 'Diana', 'Viktor', 'Albert'];

// Разнородный список
let list: [number, boolean, ...string[]] = [1, false, 'a', 'b', 'c']
```

[⬆ Back to Top](#typescript-введение-в-типизацию)

#### Создание типов для кортежей (Type Aliases)

Создание типа с аннотацией:

```ts
type Point = [number, number];

const coordinates: Point = [10, 20];

console.log(coordinates[0]); // выводит 10
console.log(coordinates[1]); // выводит 20
```

Определение функции с кортежами в качестве аргумента:

```ts
type Point = [number, number];

function calculateDistance(pointA: Point, pointB: Point): number {
  const [x1, y1] = pointA;
  const [x2, y2] = pointB;
  
  return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
}

const distance = calculateDistance([0, 0], [3, 4]);

console.log(distance); // выводит 5
```

Использование rest-параметра с кортежем:

```ts
type Point = [number, number];

function printCoordinates(...coordinates: Point[]) {
  coordinates.forEach(coord => {
    console.log(`x: ${coord[0]}, y: ${coord[1]}`);
  });
}

printCoordinates([0, 0], [1, 1], [2, 2]);

// Выводит:
// x: 0, y: 0
// x: 1, y: 1
// x: 2, y: 2
```

Пример создания типа для кортежа только для чтения:

```ts
type ReadonlyTuple = readonly [number, string];

// Пример использования
const tuple: ReadonlyTuple = [10, 'Hello'];

console.log(tuple); // [10, 'Hello']

// Ошибка! Нельзя изменить значения кортежа
tuple[0] = 20;
tuple[1] = 'World';
```

Использование утилиты `Readonly<Type>`:

```ts
type ReadonlyTuple = Readonly<[number, string]>;
```

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Типизация функций

#### Объявление и вызов функций

В TypeScript как и в JavaScript функции это объекты первого уровня, их можно присваивать другим переменным и передавать другим функциям, возвращать из функций, присваивать объектам
и прототипам, записывать в них свойства, считывать эти свойства и т. д.

Пример объявления функции с явным аннотированием параметров и возвращаемого значения:

```ts
function sum(a: number, b: number): number {
  return a + b;
}
```

> Явное аннотирование типов для параметров и возвращаемого значения является рекомендованным способом в большинстве случаев.

В JavaScript и TypeScript предлагается как минимум пять способов объявления функции:

```ts
// Именованная функция (Faunction declaration)
function greet(name: string) {
  return 'hello ' + name;
}

// Функциональное выражение (Function expression)
let greet2 = function(name: string) {
  return 'hello ' + name;
}

// Выражение стрелочной функции (Arrow function)
let greet3 = (name: string) => {
  return 'hello ' + name;
}

// Сокращенное выражение стрелочной функции (Short arrow function)
let greet4 = (name: string) =>
  'hello ' + name;

// Конструктор функции (Constructor function)
const greet5 = new Function('name', 'return "hello " + name')
```

> Конструктор функции не является рекомендованным способом объявления функции.

**Что такое параметры и аргументы функций в TypeScript**

**Параметры функций** (формальные параметры) часть декларации функции:

- Параметры функций определяются в списке параметров функции и используются для передачи значений внутрь функции.
- TypeScript позволяет явно указывать типы параметров, чтобы обеспечить безопасность типов.
- Также можно указывать значения параметров по умолчанию и необязательные параметры.

```ts
function greet(name: string, greeting: string): void {
  console.log(`${greeting}, ${name}!`);
}
```

**Аргументы функций** (входные данные функции):

- Аргументы функций представляют собой значения, которые передаются в функцию при её вызове.
- TypeScript использует аргументы для проверки типов и соответствия параметрам функции.

```ts
greet('Alice', 'Hello'); // Выводит "Hello, Alice!"
greet('Bob', 'Hi'); // Выводит "Hi, Bob!"
```

[⬆ Back to Top](#typescript-введение-в-типизацию)

#### Параметры по умолчанию

**Параметры со значениями по умолчанию:**

- Параметры функций могут иметь значения по умолчанию, которые используются, если аргумент не передан при вызове функции.
- Значения по умолчанию указываются после типа параметра с помощью знака равно (`=`).

```ts
function greet(name: string, greeting = 'Hello'): void {
  console.log(`${greeting}, ${name}!`);
}

greet('Alice'); // Выводит "Hello, Alice!"
greet('Bob', 'Hi'); // Выводит "Hi, Bob!"
```

При присваиваниии значения по умолчанию нет необходимости указывать аннотацию типа, так как TypeScript способен вывести тип параметра на основе его значения по умолчанию.

[⬆ Back to Top](#typescript-введение-в-типизацию)

#### Опциональные параметры

- В TypeScript вы можете определять параметры функций как опциональные, добавляя знак вопроса после имени параметра.
- Опциональные параметры могут быть пропущены при вызове функции, и им будет присвоено значение `undefined`.

```ts
function printName(firstName: string, lastName?: string): void {
  if (lastName) {
    console.log(`${firstName} ${lastName}`);
  } else {
    console.log(firstName);
  }
}

printName('John'); // Выводит "John"
printName('Jane', 'Doe'); // Выводит "Jane Doe"
```

При объявлении функции опциональные параметры должны быть последними в списке параметров функции.

[⬆ Back to Top](#typescript-введение-в-типизацию)

#### Оставшиеся параметры (Rest parameters)

В TypeScript можно определить функцию с переменным числом аргументов, используя "оставшиеся параметры" (Rest parameters). Оставшиеся параметры представляют собой способ захвата произвольного количества аргументов, переданных в функцию, в виде массива.

Для определения оставшихся параметров используется троеточие (`...`) перед именем параметра. Этот параметр будет представлять собой массив, содержащий все оставшиеся аргументы, которые не были сопоставлены с другими параметрами функции.

```ts
function sumVariadicSafe(...numbers: number[]): number {
  return numbers.reduce((total, n) => total + n, 0)
}

sumVariadicSafe(1, 2, 3) // вычисляется как 6.
```

Важно: функция может иметь не более одного оставшегося параметра, и этот параметр должен быть последним в списке.

[⬆ Back to Top](#typescript-введение-в-типизацию)

#### Методы `call`, `apply` и `bind`

Поведение методов `call`, `apply` и `bind` в TypeScript совпадает с поведением в JavaScript:

- Метод `apply` привязывает значение к `this` внутри функции и вторым аргументом объединяет параметры функции.
- Метод `call` делает то же самое что и `apply`, но применяет все аргументы по порядку вместо объединения.
- Метод `bind` схож с ними в том, что привязывает к функции аргумент `this` и список аргументов. Разница в том, что вместо вызова старой функции `bind` возвращает новую, которую затем вы можете вызвать с `()`,

В этом примере мы привязываем к `this` `null`:

```ts
function add(a: number, b: number): void {
  console.log( a + b)
}

add(10, 20) // Выводит 30

add.apply(null, [10, 20]) // Выводит 30
add.call(null, 10, 20) // Выводит 30
add.bind(null, 10, 20)() // Выводит 30
```

Для безопасного использования методов `call`, `apply` и `bind`, включите опцию `strictBindCallApply` в tsconfig.json (автоматически включается при включении режима strict).

[⬆ Back to Top](#typescript-введение-в-типизацию)

## Перечисления Enum

Enum является способом перечисления возможных значений типа. Он представляет собой неупорядоченную структуру данных, которая сопоставляет ключи и значения.

Enum в TypeScript является объектом, существует два типа `enum`:

1. Enum с названием (строки в строки).
  ```ts
  enum Direction {
    Up = 'UP',
    Down = 'DOWN',
    Left = 'LEFT',
    Right = 'RIGHT'
  }
  ````
2. Enum с числовым значением (строки в числа). В этом случае TypeScript автоматически будет генерировать число в качестве значения, отсчет будет начинаться с нуля.
  ```ts
  enum Language {
    English, // 0
    Spanish, // 1
    Russian  // 3
  };
  ```

Общепринято, что имена `enum` записываются в формате _CamelCase_ и начинаются с верхнего регистра и имеют форму единственного числа. Его ключи также начинаются с верхнего регистра в формате _CamelCase_.

Пример `enum` с явным указанием числового значения:

```ts
enum Language {
  English = 1,
  Spanish = 2,
  Russian = 3
}
```

Для получения значений из Enum используется нотация обычного объекта.
Например, в приведенном примере `Language.English` будет равно `1`.:

```ts
console.log(Language.English); // 1
console.log(Language['Spanish']); // 2
console.log(Language.Russian); // 3
```

В качестве значения можно использовать вычисляемое значение:

```ts
enum Language {
  English = 100,
  Spanish = 200 + 300,
  Russian // TypeScript выводит 501 (число, следующее за 500)
}
```

[⬆ Back to Top](#typescript-введение-в-типизацию)

## Операции над типами

### Объединение типов

В TypeScript объединение типов с использованием оператора `|` (или "pipe") позволяет создавать новые типы путем объединения нескольких существующих типов.

Синтаксис объединения типов выглядит следующим образом:

```ts
type TypeA = { propA: string };
type TypeB = { propB: number };

type CombinedType = TypeA | TypeB;
```

В приведенном примере `CombinedType` объединяет свойства из `TypeA` и `TypeB`.
Это означает, что значение `CombinedType` может быть либо объектом с свойством `propA` и типом `string`, либо объектом с свойством `propB` и типом `number`.
Объекты с обоими свойствами также могут соответствовать типу `CombinedType`.

Объединение типов полезно в нескольких случаях:

- **Обработка разных вариантов значений в одной переменной**. Объединение типов позволяет создавать переменные, которые могут хранить значения различных типов.
  ```ts
  let value: string | number;
  
  value = 'hello';
  console.log(value.length); // OK
  
  value = 42;
  console.log(value + 1); // OK
  ```
- **Определение общих свойств в различных типах**. Если вам нужно создать тип, который сочетает общие свойства из нескольких типов, объединение типов поможет в этом.
  ```ts
  type Shape = { color: string };
  type Circle = Shape & { radius: number };
  type Rectangle = Shape & { width: number; height: number };
  
  const circle: Circle = { color: 'red', radius: 5 };
  const rectangle: Rectangle = { color: 'blue', width: 10, height: 20 };
  ```
- **Обработка альтернативных вариантов в функциях или методах**. Если функция должна принимать разные типы аргументов или возвращать разные типы значений в зависимости от условий, объединение типов позволяет явно указать возможные варианты
  ```ts
  function processValue(value: string | number): void {
    if (typeof value === 'string') {
      console.log(value.toUpperCase());
    } else if (typeof value === 'number') {
      console.log(value.toFixed(2));
    }
  }
  
  processValue('hello'); // HELLO
  processValue(3.1415); // 3.14
  ```

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Пересечение типов (Intersection Type)

В TypeScript пересечение типов представляет собой конструкцию, которая позволяет объединить два или более типа в один общий тип, который будет иметь все свойства и методы каждого из объединенных типов.
Это достигается с помощью оператора `&`.

Пример использования пересечения типов:

```ts
type Person = {
  name: string;
  age: number;
};

type Employee = {
  company: string;
  position: string;
};

type EmployeePerson = Person & Employee;

const user: EmployeePerson = {
  name: 'John',
  age: 30,
  company: 'ABC Corp',
  position: 'Manager',
};
```

В данном примере создается два типа - `Person` и `Employee`, а затем они объединяются в новый тип `EmployeePerson` с помощью оператора `&`.
Теперь объекты типа `EmployeePerson` будут иметь все свойства и методы, определенные и в типе `Person`, и в типе `Employee`.

Пересечение типов широко используется для объединения нескольких интерфейсов или типов данных, когда необходимо создать новый тип, который обладает всеми свойствами и методами каждого из объединенных типов.
Это может быть полезно, например, при создании типов для сложных объектов или использовании декораторов. Кроме того, пересечение типов может помочь избежать дублирования кода при объединении свойств и методов нескольких типов.

Однако стоит помнить, что пересечение типов может привести к большому количеству свойств и методов в новом типе, что может затруднить чтение и понимание кода.
Поэтому рекомендуется использовать пересечение типов с осторожностью и только при необходимости.

[⬆ Back to Top](#typescript-введение-в-типизацию)

## Классы и интерфейсы

### Общее определение класса

Класс - это строительный блок в TypeScript и других объектно-ориентированных языках программирования.
Он является шаблоном или моделью для создания объектов, объединяющих свойства (переменные) и методы (функции) в единый контейнер (в TypeScript свойства класса принято называть полями - Fields).

Определение класса в TypeScript осуществляется с использованием ключевого слова `class`, за которым следует имя класса. Класс может содержать функцию-конструктор (метод, который вызывается при создании нового объекта), поля (переменные, хранящие состояние объекта) и методы (функции, выполняющие операции над объектом).

> Члены класса - это общее название для полей и методов класса.

Пример класса:

```ts
class Person {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }

  sayHello(): void {
    console.log(`Hello, my name is ${this.name} and I'm ${this.age} years old.`);
  }
}

const person = new Person('John', 25);

person.sayHello();
```

В данном примере определен класс `Person`, который имеет два поля (`name` и `age`), конструктор `constructor` и метод (`sayHello`).
Конструктор принимает два параметра - `name` и `age`, а затем присваивает их значениям полей `name` и `age` объекта класса (экземпляр класса).

> Экземпляр класса - это объект, созданный на основе определенного класса. Он содержит поля и методы, которые были определены в классе. Экземпляр класса доступен для использования и может быть присвоен переменной или передан в функцию как аргумент. Можно создать несколько экземпляров класса, каждый из которых будет иметь свое собственное состояние и поведение, определенное в классе.

Метод `sayHello` выводит в консоль приветствие и использует значения полей `name` и `age` объекта.

Затем создается объект `person1`, используя ключевое слово `new` и вызывая конструктор класса `Person`. После этого вызывается метод `sayHello` у объекта `person1`, который выводит приветствие с именем и возрастом объекта.

> Hello, my name is John and I'm 25 years old.

Помимо своей основной цели, класс так же является определением типа данных.
Это означает, что объекты (экземпляры класса), созданные на основе этого класса, будут иметь тип `Person`, а само название класса может использоваться для аннотации типа данных.

```ts
function greet(person: Person): Person {
  console.log(`Hello, my name is ${person.name} and I'm ${person.age} years old.`);
  
  return person;
}

greet(person);
```

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Модификаторы доступа

TypeScript поддерживает три модификатора доступа для свойств и методов класса.

- **public** - Доступен отовсюду. Это уровень доступа по умолчанию, то есть если модификатор не указан.
- **protected** - Доступен из экземпляров определенного класса и его подклассов.
- **private** - Доступен только из экземпляров определенного класса, не доступен для подклассов.

Модификаторы доступа указываются в начале свойства или метода, непосредственно перед идентификатором.

Пример класса с публичным свойством и методом:

```ts
class Animal {
  public name: string;

  constructor(name: string) {
    this.name = name;
  }

  public makeSound(): void {
    console.log(`${this.name} makes a sound`);
  }
}

let cat = new Animal('Cat');
console.log(cat.name); // доступ к публичному свойству
cat.makeSound(); // вызов публичного метода
```

Пример класса с приватным свойством и методом:

```ts
class Person {
  private age: number;

  constructor(age: number) {
    this.age = age;
  }

  private getAge() {
    return this.age;
  }
}

let person = new Person(25);
console.log(person.age); // Ошибка: недоступно из-за приватности
console.log(person.getAge()); // Ошибка: недоступно из-за приватности
```

Пример класса с защищенным свойством и методом:

```ts
class Employee {
  protected salary: number;

  constructor(salary: number) {
    this.salary = salary;
  }

  protected getSalary() {
    return this.salary;
  }
}

class Manager extends Employee {
  getManagerSalary() {
    return this.getSalary(); // доступ к защищенному методу родительского класса
  }
}

let employee = new Employee(50000);
console.log(employee.salary); // Ошибка: недоступно из-за защищенности
console.log(employee.getSalary()); // Ошибка: недоступно из-за защищенности

let manager = new Manager(75000);
console.log(manager.getManagerSalary()); // 75000
```

Хорошим правилом является всегда явно указывать модификатор доступа `public` для публичных свойств и методов класса, это делает структуру класса более понятной и повышает читабельность кода.

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Обращение к закрытым свойствам другого экземпляра

В TypeScript свойство, объявленное с модификатором `private` или `protected`, доступно только внутри того класса, в котором оно было объявлено.
Оно не доступно из других классов, но к нему можно получить доступ из экземпляра того же класса:

```ts
class Person {
  private name: string;

  constructor(name = 'John') {
    this.name = name;
  }

  public greet(): void {
    console.log(`Hello, my name is ${this.name}.`);
  }

  public greetFromOtherPerson(otherPerson: Person): void {
    console.log(`Nice to meet you, ${otherPerson.name}.`);
  }
}

const person1 = new Person();
const person2 = new Person('Jane');

console.log(person1.greet()); // Hello, my name is John.
console.log(person1.greetFromOtherPerson(person2)); // Hello, my name is Jane.
```

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Сигнатура индекса в объявлении класса

Классы могут объявлять сигнатуры индекса, это работает точно так же как и у объектов.
Этот механизм позволяет определить, какой тип данных может использоваться в качестве индекса для доступа к полям (свойствам) объекта класса.

```ts
class MyDictionary {
  [index: string]: string;
}

let myDict = new MyDictionary();

myDict['apple'] = 'A fruit';
myDict['banana'] = 'Another fruit';

console.log(myDict['apple']);  // Выведет: A fruit
```

При использовании типов в сигнатуре индекса для класса в TypeScript, есть определённые ограничения и особенности, которые могут затруднить использование типов с пользой.

Например, если вы хотите иметь какие-то другие методы или свойства у класса, которые не соответствуют сигнатуре индекса, то могут возникнуть проблемы с типизацией.

В целом, использование сигнатуры индекса для класса в TypeScript может быть полезным для определения динамических структур данных, но при этом придется аккуратно обращаться с типами, чтобы избежать сложностей и неоднозначностей.

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Классы и наследование

Наследование в TypeScript позволяет определять новый класс на основе уже существующего класса (базового/родительского).
При этом новый класс будет иметь доступ к свойствам и методам базового класса, а также может добавлять свои собственные свойства и методы, и переопределять существующие.

В TypeScript используется простое наследование, или как его еще называют одиночное наследование.
При одиночном наследовании, каждый класс имеет только один базовый класс.

Для создания наследования в TypeScript используется ключевое слово `extends`.
Например, если у нас есть класс `Animal`, то вы можете создать новый класс `Dog` и унаследовать его от `Animal` следующим образом:

```ts
class Animal {
  public name: string;

  constructor(name: string) {
    this.name = name;
  }

  public speak(): void {
    console.log('Some sound');
  }
}

class Dog extends Animal {
  public breed: string;

  constructor(name: string, breed: string) {
    super(name);
    
    this.breed = breed;
  }

  public speak(): void {
    console.log('Woof!');
  }
}

const dog = new Dog('Buddy', 'Labrador');

console.log(dog.name); // Выводит "Buddy"
console.log(dog.breed); // Выводит "Labrador"
dog.speak(); // Выводит "Buddy barks."
```

В этом примере класс `Dog` наследует свойства и методы от класса `Animal`. Класс `Dog` также определяет свое уникальное свойство `breed` и переопределяет метод `speak()`, чтобы собака лаяла вместо издания общего звука.

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Переопределение конструктора

Если подкласс определяет свой конструктор, то в нем **обязательно** должен быть вызван конструктор базового класса с помощью ключевого слова `super`:

```ts
class Animal {
  public name: string;

  constructor(name: string) {
    this.name = name;
  }

  public walk(): void {
    console.log(`${this.name} is walking`);
  }
}

class Dog extends Animal {
  public breed: string;

  constructor(name: string, breed: string) {
    super(name); // Вызываем конструктор родительского класса

    this.breed = breed;
  }

  public bark(): void {
    console.log(`${this.name} is barking`);
  }
}

const myDog = new Dog('Buddy', 'Labrador');
myDog.walk(); // Вывод: Buddy is walking
myDog.bark(); // Вывод: Buddy is barking
```

В этом примере класс `Animal` имеет одно поле name и метод `walk()`, а класс `Dog` наследует класс `Animal` и добавляет своё поле `breed` и метод `bark()`.

Когда мы создаём экземпляр класса `Dog`, конструктор `Dog` вызывает конструктор родительского класса `Animal`, используя ключевое слово `super`, и передаёт ему аргумент `name`.
Затем конструктор `Dog` инициализирует своё поле `breed` значением, переданным в конструктор `Dog`.

Помимо вызова `super()` в конструкторе, мы можем вызвать методы родительского класса через объект `super`, который всегда ссылается на родительский класс:

```ts
class Cat extends Animal {
 //...
  public meow(): void {
    super.walk(); // Вызываем метод родительского класса
    
    console.log(`${this.name} is meowing`);
  }
}
```

Обратите внимание, что посредством `super` можно обращаться только к методам родительского класса, но не к его свойствам.

### Абстрактные классы

В TypeScript можно создавать абстрактные классы, которые представляют собой базовые классы, от которых можно наследовать другие классы.
Абстрактный класс может содержать абстрактные методы и свойства, которые должны быть реализованы в классах-наследниках.

Вот пример абстрактного класса:

```ts
abstract class Base {
  abstract getName(): string;
 
  printName() {
    console.log('Hello, ' + this.getName());
  }
}
 
const b = new Base(); // Error: Cannot create an instance of an abstract class
```

Нельзя создать экземпляр абстрактного класса, абстрактный класс должен быть расширен или наследован другими классами и все абстрактные методы и свойства должны быть реализованы в дочернем классе.

```ts
class Derived extends Base {
  getName() {
    return 'world';
  }
}
 
const d = new Derived();
d.printName(); // Выведет "Hello, world"
```

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Структурная типизация классов

Как и все типы, TypeScript сравнивает классы по их структуре, а не по имени класса, класс будет совместим с любым другим типом если они имеют одинаковую структуру.

```ts
class Dog {
  public makeSound() {
    console.log('Dog makes a sound');
  }
}
class Cat {
  public makeSound() {
    console.log('Cat makes a sound');
  }
}

function makeSound(animal: Dog) {
  animal.makeSound();
}

// Создание экземпляра класса
// без вызова конструктора класса
const dog = new Dog; 
const cat = new Cat;

makeSound(dog); // OK: Dog makes a sound
makeSound(cat); // OK: Cat makes a sound
```

Исключением из этого правила будут классы с полями объявленными как `private` или `protected`.

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Статические свойства и методы класса

Статические члены в TypeScript позволяют создавать свойства и методы, которые принадлежат самому классу, а не его экземплярам.
Они доступны непосредственно через имя класса, без необходимости создания экземпляра класса.

Статические свойства и методы могут быть использованы, например, для хранения общих данных или функциональности, которая не зависит от конкретных экземпляров класса.

```ts
class MathUtils {
  public static PI: number = 3.14;

  public static calculateArea(radius: number): number {
    return this.PI * radius * radius;
  }
}

console.log(MathUtils.PI); // Выводит 3.14

const result = MathUtils.calculateArea(5, 3);
console.log(result); // Выводит 78.5
```

Еще один пример использования статических членов - создание утилитарных классов, которые предоставляют общие функции для работы с определенными данными или операциями.
Например, класс `StringUtils` может содержать статические методы для работы со строками:

```ts
class StringUtils {
  public static capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  public static reverse(str: string): string {
    return str.split('').reverse().join('');
  }
}

console.log(StringUtils.capitalize('hello')); // Выводит "Hello"
console.log(StringUtils.reverse('world')); // Выводит "dlrow"
```

Статические свойства и методы могут быть объявлены как `public`, `private` или `protected` с соответствующим доступом, и могут наследоваться как обычные свойства и методы.

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Тип `this`

В классах специальный тип `this` динамически ссылается на тип текущего класса:

```ts
// (method) Box.set(value: string): this
class Box {
  contents: string = '';

  set(value: string) {
    this.contents = value;

    return this;
  }
}

const box = new Box().set('Hello');

console.log(box.contents);
```

В этом примере TypeScript определил возвращаемое значение для метода `set` как тип `this`, который в свою очередь ссылается на тип `Box` возвращаемого экземпляра.

Теперь давайте расширим класс `Box` новым дочерним классом `ClearableBox`:

> Расширение класса (наследование) в TypeScript означает создание нового класса, который наследует свойства и методы от существующего (базового) класса, базовый класс еще называют супер классом (аналогия с конструктором `super()`).

```ts
class ClearableBox extends Box {
  clear() {
    this.contents = '';
  }
}

const a = new ClearableBox();
const b = a.set('hello'); // const b: ClearableBox

console.log(b instanceof ClearableBox); // true
console.log(b instanceof Box); // true
```

Оператор `instanceof` в TypeScript используется для проверки, является ли объект экземпляром определённого класса или его подкласса.

Вы также можете использовать `this` в аннотации типа параметра для конструктора или метода класса:

```ts
class Box {
  content: string = '';
 
  sameAs(other: this) {
    return other.content === this.content;
  }
}
```

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Защита типа на основе this (this-based type guards)

> Защита типа (type guards) в TypeScript - это механизм, который позволяет проверять тип переменной во время выполнения программы и принимать соответствующие действия в зависимости от этого типа.

В TypeScript, **this-based type guards** - это способ использования `this` в методах класса для определения типов данных.

Благодаря этому методу можно использовать информацию о типе объекта, на котором вызывается метод, для определения типов данных внутри этого метода. Давайте рассмотрим пример:

```ts
class Car {
  make: string;
  
  constructor(make: string) {
    this.make = make;
  }

  isElectric(): this is ElectricCar {
    return this instanceof ElectricCar;
  }
  
  isGas(): this is GasCar {
    return this instanceof GasCar;
  }
}

class ElectricCar extends Car {
  range: number;
  
  constructor(make: string, range: number) {
    super(make);
    this.range = range;
  }
}

class GasCar extends Car {
  milesPerGallon: number;
  
  constructor(make: string, milesPerGallon: number) {
    super(make);
    this.milesPerGallon = milesPerGallon;
  }
}

function getCarDetails(car: Car) {
  if (car.isElectric()) {
    console.log(`${car.make} is an electric car with a range of ${car.range} miles.`);
  }
  
  if (car.isGas()) {
    console.log(`${car.make} is a gas car with a fuel efficiency of ${car.milesPerGallon} miles per gallon.`);
  }
}

const myElectricCar = new ElectricCar('Tesla', 300);
const myGasCar = new GasCar('Toyota', 40);

getCarDetails(myElectricCar); // "Tesla is an electric car with a range of 300 miles."
getCarDetails(myGasCar); // "Toyota is a gas car with a fuel efficiency of 40 miles per gallon."
```

Здесь метод `isElectric` возвращает `true`, если объект, на котором вызывается метод, является экземпляром `ElectricCar`, иначе возвращает `false`, аналогично работает метод `isGas`.
Это позволяет использовать `this` в качестве **type guard**, чтобы определить тип объекта и использовать соответствующие свойства.

[⬆ Back to Top](#typescript-введение-в-типизацию)


### Интерфейсы

> Интерфейсы можно использовать для описания объекта, именования и параметризации типов объектов, а также для составления существующих типов именованных объектов в новые.

Этот простой интерфейс определяет два свойства и метод объекта Employee:

```ts
interface Employee {
  firstName: string;
  lastName: string;
  fullName(): string;
}
```

Обратите внимание, что интерфейс не инициализирует и не реализует свойства, объявленные внутри него. Единственным заданием интерфейса является описание типа.

В этом примере интерфейс реализуется путем объявления переменной типа Employee.

```ts
let employee: Employee = {
  firstName: 'John',
  lastName: 'Doe',
  fullName: function() {
    return this.firstName + ' ' + this.lastName;
  }
}

employee.firstName = 10;  //* Error - Type 'number' is not assignable to type 'string'
```
Проверка типа гарантирует, что число 10 не может быть назначено `employee.firstName`, так как ожидается `string`.

Интерфейс можно использовать в следующих целях:

- Создание сокращенных имен для часто используемых типов. При использовании даже простого интерфейса, подобного описанному в предыдущем примере, вы по-прежнему получаете преимущества IntelliSense и проверки типов.
- Согласованность типов в наборе объектов, так как каждый объект, реализующий интерфейс, работает с теми же определениями типов. .
- Описание существующих API-интерфейсов JavaScript и уточнение параметров функции и типов возвращаемого значения. Это особенно полезно при работе с библиотеками JavaScript.

Псевдонимы и интерфейсы очень похожи и в обоих случаях используются для описания типов.
Интерфейсы, как и псевдонимы не компилируются в JavaScript код, но дают возможность провести статическую проверку типов и обеспечить совместимость между различными частями кода.

Рассмотрим следующий пример определения псевдонима типа:

```ts
// Псевдоним (type)
type Sushi = {
  calories: number;
  salty: boolean;
  tasty: boolean;
}
```

Его легко переписать с использованием интерфейса:

```ts
// Интерфейс (interface)
interface Sushi {
  calories: number;
  salty: boolean;
  tasty: boolean;
}
```

Псевдоним `Sushi` легко заменить на интерфейс `Sushi`, обе декларации определяют один и тот же тип и они идентичны (структурная типизация).

#### Различие между интерфейсами и псевдонимами

Между интерфейсами и псевдонимами существует три отличия:

- Псевдонимы типов более обобщены, их правая часть может быть любого типа и может включать выражения типа, в то время как интерфейс может быть только формой объекта. Например следующие псевдонимы типов никак не переписать в виде интерфейсов:
  ```ts
  type A = number
  type B = A | string
  ``` 
- Интерфейсы при расширении не допускают перегруженных сигнатур (перегрузка методов и функций) в отличие от псевдонимов. При расширении интерфейса TypeScript будет проверять совместимость интерфейса с произведенным вами расширением:
  ```ts
  interface A {
    good(x: number): string;
    bad(x: number): string;
  }
  
  interface B extends A {
    good(x: string | number): string;
    bad(x: string): string; // Интерфейс «B» неправильно расширяет интерфейс «A».
  }
  ```
- Несколько интерфейсов с одинаковым именем в одной области подвергаются автоматическому слиянию. А несколько одноименных псевдонимов типов в одной области будут вызывать ошибку при компиляции.
  Этот механизм называется **слиянием деклараций**.
  ```ts
  // Не вызывает ошибки
  interface Person {
    name: string;
  }
  
  interface Person {
    age: 12;
  }
  
  // Итоговый интерфейс включает в себя две декларации
  const person: Person = {
    name: 'Jane',
    age: 12
  }
  ```

Ключевое отличие заключается в том, что псевдоним типа нельзя открыть повторно, чтобы добавить новые свойства, в то время как интерфейс можно легко расширять. Кроме того, с помощью псевдонима типа можно описать только объединение или кортеж.

#### Расширение интерфейса

Интерфейсы в TypeScript также могут быть расширены другими интерфейсами или реализованы классами. Это дает возможность создавать иерархию и специализировать поведение для конкретных типов данных.

Пример расширения интерфейса:

```ts
interface Animal {
  name: string;
}

interface Dog extends Animal {
  breed: string;
}

let myDog: Dog = { name: 'Buddy', breed: 'Golden Retriever' };
```

В этом примере интерфейс `Dog` расширяет интерфейс `Animal`, добавляя к нему дополнительное свойство `breed`.
Новый объект myDog, имеющий тип `Dog` будет содержать и `name`, и `breed`.


Рассмотрим пример комбинирования типов (пересечение типов) для псевдонима и интерфейса:

```ts
// Псевдоним (type)
type Food = {
  calories: number
  tasty: boolean;
}

type Sushi = Food & {
  salty: boolean;
}

type Cake = Food & {
  sweet: boolean;
}
```

Это легко переписать с использованием интерфейса:

```ts
// Интерфейс (interface)
interface Food {
  calories: number;
  tasty: boolean;
}

interface Sushi extends Food {
  salty: boolean;
}

interface Cake extends Food {
  sweet: boolean;
}
```

Интерфейсы могут расширять сразу несколько других интерфейсов.
Это позволяет комбинировать и объединять различные интерфейсы в один более сложный интерфейс.

```ts
interface Printable {
  print(): void;
}

interface Drawable {
  draw(): void;
}

interface Shape extends Printable, Drawable {
  color: string;
}

class Circle implements Shape {
  color: string;
  
  constructor(color: string) {
    this.color = color;
  }
  
  print() {
    console.log('Printing circle');
  }
  
  draw() {
    console.log('Drawing circle');
  }
}
```

В этом примере интерфейс `Shape` расширяет интерфейсы `Printable` и `Drawable`, добавляя к ним свойство `color`.
Класс `Circle` реализует интерфейс `Shape`, обеспечивая реализацию методов `print` и `draw`.

#### Создание перекрестных типов (intersection types)

TypeScript позволяет создавать перекрестные типы (intersection types) из нескольких интерфейсов c помощью литерала `&`:
Это позволяет создавать новый тип, который содержит все члены каждого из исходных типов.

```ts
interface Printable {
  print(): void;
}

interface Loggable {
  log(): void;
}

type PrintableAndLoggable = Printable & Loggable;

class Logger implements PrintableAndLoggable {
  print() {
    console.log('Printing');
  }
  
  log() {
    console.log('Logging');
  }
}
```

В этом примере создается новый тип `PrintableAndLoggable`, который объединяет функциональность из интерфейсов `Printable` и `Loggable`.
Затем класс `Logger` реализует этот новый тип, обеспечивая реализацию методов `print` и `log`.

[⬆ Back to Top](#typescript-введение-в-типизацию)

#### Создание индексируемых типов (сигнатура индекса)

Для создания индексируемого типа в интерфейсе используется специальная нотация, которая включает ключевое слово `index` и тип ключа доступа к объекту.

Например, интерфейс `IceCreamArray` объявляет сигнатуру индекса как `number` и возвращает тип `string`.
Эта сигнатура индекса указывает, что `IceCreamArray` индексируется числом и будет возвращать строку.

```ts
interface IceCreamArray {
    [index: number]: string;
}

let myIceCream: IceCreamArray;
myIceCream = ['chocolate', 'vanilla', 'strawberry'];

let myStr: string = myIceCream[0];
console.log(myStr);
```

Можно также использовать встроенный тип массива или псевдоним типа для пользовательского массива, но с помощью интерфейса можно определить собственный тип массива, чтобы любой, кто хочет работать с этим интерфейсом, мог применять его согласованно.

[⬆ Back to Top](#typescript-введение-в-типизацию)

#### Пример описания API JavaScript с помощью интерфейса

С помощью интерфейса в TypeScript можно создать интерфейс, чтобы описывать существующие API-интерфейсы JavaScript и уточнять параметры функции и типы возвращаемого значения.
Интерфейс дает четкое представление о том, что ожидает API и что он будет возвращать.

```ts
const fetchURL = 'https://jsonplaceholder.typicode.com/posts'

// Интерфейс, описывающий форму наших данных json
interface Post {
  userId: number;
  id: number;
  title: string;
  body: string;
}

async function fetchPosts(url: string): Promise<Post[]> {
  const response = await fetch(url);
  const body = await response.json();
  
  return body as Post[];
}

async function showPost() {
  const posts = await fetchPosts(fetchURL);

  // Отображение содержимого первого элемента ответа
  const { userId, id, title, body } = posts[0];

  console.log('Post #' + id);

  // Если идентификатор пользователя равен 1, 
  // отобразить примечание о том, что он является администратором.
  console.log('Author: ' + (userId === 1 ? 'Administrator' : userId.toString()));
  
  console.log('Title: ' + title);
  console.log('Body: ' + body);
}

showPost();
```

В этом примере объявляется интерфейс `Post` для возвращаемых типов в JSON-файле, а затем используется `fetch` с `async` и `await` для создания строго типизированного ответа.

Следующий пример показывает, как можно использовать интерфейс в TypeScript вместе с классом:

```ts
interface MyApi {
  getUser(id: number): Promise<User>;
  updateUser(id: number, data: Partial<User>): Promise<User>;
  deleteUser(id: number): Promise<void>;
}

interface User {
  id: number;
  name: string;
  email: string;
  // Дополнительные свойства пользователя
}

// Реализация API
class MyApiImplementation implements MyApi {
  getUser(id: number): Promise<User> {
    // Реализация метода getUser
  }
  updateUser(id: number, data: Partial<User>): Promise<User> {
    // Реализация метода updateUser
  }
  deleteUser(id: number): Promise<void> {
    // Реализация метода deleteUser
  }
}
```

В этом примере `MyApi` определяет интерфейс для API, который включает методы для получения, обновления и удаления пользователей.
Также определена интерфейс `User`, описывающая структуру объекта пользователя.

Затем класс `MyApiImplementation` реализует интерфейс `MyApi`, обеспечивая конкретную реализацию каждого метода API.

[⬆ Back to Top](#typescript-введение-в-типизацию)

## Слияние деклараций

Слияние деклараций - это механизм, который позволяет объединять несколько объявлений с одинаковыми именами в одно.

**Основная концепция**

В TypeScript объявление создает сущности как минимум в одной из трех групп: пространство имен (namespace), тип (type) или значение (value).
Объявления, создающие пространство имен, создают пространство имен, содержащее имена, доступ к которым осуществляется с помощью точечной записи.  Объявления, создающие тип, делают именно это: они создают видимый тип с объявленной формой и привязанный к данному имени.  Наконец, объявления, создающие значения, создают значения, которые видны в выходном коде JavaScript.

|Declaration Type   | Namespace |  Type | Value |
|---|-----------|---|-------|
| Namespace  | ✅         | ❌  | ✅     |
| Class  | ❌         | ✅  | ✅     |
| Enum  | ❌         |  ✅ | ✅     |
| Interface  | ❌         | ✅  | ❌     |
| Type Alias  | ❌         | ✅  | ❌     |
| Function  | ❌         | ❌  | ✅     |
| Variable  | ❌         |  ❌ | ✅     |

Пример слияния деклараций Enum:

```ts
enum Status {
  Pending = 1,
  Done = 2
}

// Теперь Status имеет значения
enum Status {
  Error = 3
}
```

В итоге два перечисления объединятся, чтобы создать одну декларацию вида:

```ts
enum Status {
  Pending = 1,
  Done = 2,
  Error = 3
}
```

Самый простой и, возможно, наиболее распространенный тип слияния объявлений - это слияние интерфейсов.
На самом базовом уровне слияние автоматически объединяет члены обоих объявлений в единый интерфейс с тем же именем.

```ts
// Интерфейс Person имеет одно поле, name
interface Person {
  name: string;
  address: string;
}

// Теперь интерфейс Person имеет три поля, name, address и age
interface Person {
  age: number;
}

let person: Person = {age: 23, name: 'Jane', address: '123 Main St'};
```

Порядок слияния  выполняется по приоритету снизу вверх, то есть
в случае слияния интерфейса `Person` с более поздним интерфейсом `Person` второй интерфейс будет иметь более высокий приоритет, чем первый.

```ts
interface Person {
  age: number;
  name: string;
  address: string;
}
```

[⬆ Back to Top](#typescript-введение-в-типизацию)

## Сужение типов (Narrowing)

### Защита типа на основе `typeof`

Защита типа в TypeScript на основе оператора `typeof` используется для проверки типа значения переменной или свойства объекта во время выполнения кода.

При использовании оператора `typeof`, TypeScript ожидает, что оператор `typeof` возвращает строковое представление типа значения из следующего набора строк:

- "string"
- "number"
- "bigint"
- "boolean"
- "symbol"
- "undefined"
- "object"
- "function"

Простой пример с использованием оператора `typeof`:

```ts
function processValue(value: string | number): void {
  if (typeof value === 'string') {
    // выполняем логику для значения типа string
    console.log('Строковое значение:', value.toUpperCase());
  } else if (typeof value === 'number') {
    // выполняем логику для значения типа number
    console.log('Числовое значение:', value * 2);
  } else {
    console.log('Неизвестный тип значения');
  }
}

processValue('Hello'); // Строковое значение: HELLO
processValue(42); // Числовое значение: 84
```

В этом примере при выполнении оператора `typeof` TypeScript автоматически сужает тип до проверяемого типа если условие будет выполнено.

Это простой пример использования механизма **Type Guard** для проверки типа при помощи оператора `typeof`.

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Проверка истинности примитивов

В JavaScript такие конструкции, как `if` , сначала «приводят» свои условия к `boolean` , чтобы они имели смысл, а затем выбирают свои ветви в зависимости от того, будет ли результат true или false .

Такие значения, как:
- `0`
- `NaN`
- `""` (пустая строка)
- `0n` (нулевая версия `bigint`)
- `null`
- `undefined`

всегда приводятся к `false`, а все остальные значения приводятся к `true`.

Вы всегда можете привести значения к `boolean`, пропустив их через функцию `Boolean` или используя более короткое двойное логическое отрицание. (Последний имеет то преимущество, потому что TypeScript выводит узкий литерал boolean типа true , а первый - как тип boolean).

```ts
// both of these result in 'true'
Boolean('hello'); // type: boolean, value: true
!!'world'; // type: true, value: true
```

Рассмотрим пример:

```ts
function printAll(strs: string | string[] | null) {
  if (typeof strs === 'object') {
    for (const s of strs) {
      console.log(s);
    }
  } else if (typeof strs === 'string') {
    console.log(strs);
  } else {
    // ничего не делать
  }
}
```

В функции `printAll` мы пытаемся проверить, является ли `strs` объектом, чтобы увидеть, является ли он типом массива,
при этом `typeof null` на самом деле является "object" и, при передачи в функцию `null` будет выведено сообщение об ошибке `strs is not iterable`.

Исправить ситуацию можно проверив, является ли `strs` правдивым при помощи проверки истинности примитивов:

```ts
function printAll(strs: string | string[] | null) {
  if (strs && typeof strs === 'object') {
    for (const s of strs) {
      console.log(s);
    }
  } else if (typeof strs === 'string') {
    console.log(strs);
  } else {
    // ничего не делать
  }
}
```

Однако имейте в виду, что проверка истинности примитивов часто может быть подвержена ошибкам.
Например пустая строка будет обрабатываться как `false` и в ряде случаев обработка пустой строки будет не такой какой вы ожидаете.

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Оператор `in` для проверки объектов

Оператор `in` проверяет, имеет ли объект или его цепочка прототипов свойство с указанным именем:

```ts
type Fish = { swim: () => void };
type Bird = { fly: () => void };
 
function move(animal: Fish | Bird) {
  if ('swim' in animal) {
    return animal.swim();
  }
 
  return animal.fly();
}
```

Аналогично `typeof`, TypeScript автоматически сужает тип объекта `animal` до `Fish` или `Bird` в соответствующих блоках условия `if`.

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Оператор `instanceof`

Оператор instanceof используется для проверки принадлежности объекта к определенному классу или интерфейсу. Он возвращает значение `true`, если объект является экземпляром данного класса или реализует данный интерфейс, и `false` в противном случае.

Как и в случае с `typeof`, оператор `instanceof` используется для защиты типа (type guard) и автоматически сужает тип объекта  в соответствующих блоках условия `if`.

```ts
function logValue(x: Date | string) {
  if (x instanceof Date) {
    console.log(x.toUTCString()); // (parameter) x: Date
  } else {
    console.log(x.toUpperCase()); // (parameter) x: string
  }
}
```

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Защита типов на основе сравнения

TypeScript также использует операторы `switch` и проверки равенства, такие как === , !== , == и != , для сужения типов (Equality Narrowing Type Guard).
Когда TypeScript обнаруживает такое сравнение, он может сужать тип переменной до более конкретного типа, основываясь на результатах сравнения.


Рассмотрим пример с функцией, которая принимает два параметра: `x` и `y`, где `x` - это строка или число, а `y` - число.  Когда значение `x` равно значению `y`, типом `x` считается число, а в противном случае - строка.

```ts
function someFunction(x: string | number, y: number) {
  if(x === y) {
    // Сужение до "number"
    console.log(typeof x) // "number"
  } else {
    // Нет сужения
    console.log(typeof x) // "number" или "string"
  }
}
```

Еще один пример сужения типа на основе сравнения:

```ts
function printStatus(status: 'success' | 'error' | 'loading'): void {
  if (status === 'success') {
    console.log('Operation completed successfully');
  } else if (status === 'error') {
    console.log('An error occurred');
  } else {
    console.log('Operation in progress');
  }
}

printStatus('success'); // выводит "Operation completed successfully"
printStatus('error'); // выводит "An error occurred"
printStatus('loading'); // выводит "Operation in progress"
```

В этом примере функция `printStatus` принимает аргумент `status`, который может быть только одним из трех значений: "success", "error" или "loading". Когда мы сравниваем `status` с помощью оператора ===, TypeScript сужает тип переменной `status` до соответствующего литерального типа.

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Присваивание значения (Assignments)

В TypeScript присваивание значения переменной может привести к сужению (narrowing) её типа. Это происходит, когда TypeScript использует информацию о потоке управления кода, чтобы уточнить тип переменной на основе значения, которое ей присваивается.

Сужение типа с помощью литеральных значений:

```ts
let x: 'success' | 'error' | 'loading';

x = 'success'; // Тип `x` сужается до "success"
console.log(x); // Выводит "success"

x = 'error'; // Тип `x` сужается до "error"
console.log(x); // Выводит "error"
```

В этом примере переменная `x` имеет тип `success | error | loading`, то есть может принимать одно из трех литеральных значений.
Когда мы присваиваем `x` литеральное значение "success", TypeScript сужает тип `x` до `success`.
То же самое происходит и при присваивании значения "error".

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Discriminated Unions

Discriminated Unions (дискриминирующие объединения) в TypeScript - это механизм, который позволяет создавать типы, которые объединяют несколько других типов с помощью общего свойства, называемого дискриминантом.
Дискриминант является строковым литералом или числом, который определяет конкретный подтип внутри такого объединения.

```ts
interface Square {
  kind: 'square';
  size: number;
}

interface Circle {
  kind: 'circle';
  radius: number;
}

type Shape = Square | Circle;

function calculateArea(shape: Shape): number {
  if (shape.kind === 'square') {
    return shape.size ** 2;
  } else {
    return Math.PI * shape.radius ** 2;
  }
}

const square: Square = { kind: 'square', size: 5 };
const circle: Circle = { kind: 'circle', radius: 3 };

console.log(calculateArea(square)); // Выводит 25
console.log(calculateArea(circle)); // Выводит примерно 28.27
```

В этом примере созданы интерфейсы `Square` и `Circle`, а также объединение типов `Shape`, которое представляет либо квадрат, либо круг.
Оба интерфейса имеют общее свойство `kind`, которое является дискриминантом. Затем функция `calculateArea` принимает аргумент `shape` типа `Shape` и внутри условного блока типов проверяет значение `kind` для определения, является ли `shape` квадратом или кругом.

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Предикаты типов (Type predicates)

Предикат типа - это функция, возвращающая булевое значение в зависимости от типа входящего значения.

```ts
function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined;
}
```

`pet is Fish` — это предикат типа в этом примере.
Предикат принимает форму `parameterName is Type` , где `parameterName` должно быть именем параметра из текущей сигнатуры функции.

`pet as Fish` - приводит `pet` к типу `Fish` используя Type assertion, если это возможно, а затем проверяет, что `pet` имеет свойство `swim`.

Каждый раз, когда `isFish` вызывается с какой-либо переменной, TypeScript сужает эту переменную до этого конкретного типа, если исходный тип совместим.

```ts
// Both calls to 'swim' and 'fly' are now okay.
let pet = getSmallPet(); // getSmallPet() returns Bird | Fish
 
if (isFish(pet)) {
  pet.swim();
} else {
  pet.fly();
}
```

Обратите внимание, что TypeScript не только знает, что `pet` - это `Fish` в ветви `if`, он также знает, что в ветке `else` у вас нет `Fish`, поэтому у вас должен быть `Bird` .

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Анализ потока управления

Анализ кода на основе достижимости, также известный как анализ потока управления (Control Flow Analysis), является методом статического анализа кода, который позволяет определить, какие участки кода будут выполнены во время выполнения программы. Он анализирует поток управления программы, чтобы определить, какие ветви кода будут достигнуты на основе различных условий и входных данных.

В TypeScript анализ потока управления имеет важное значение для определения типов переменных. TypeScript использует информацию о достижимости кода для улучшения инференции типов и обеспечения безопасности типов во время компиляции.

```ts
function padLeft(padding: number | string, input: string) {
  if (typeof padding === 'number') {
    return ' '.repeat(padding) + input;
  }
  
  return padding + input;
}
```

Если передать `padding` как `number`, то функция `padLeft` вернется из своего первого блока `if`.
TypeScript проанализирует этот код и увидит, что остальная часть тела (`return padding + input;`) будет недоступна в случае, когда padding является `number`.
В результате тип `number` будет удален из типа `padding` и произойдет сужение от `string | number` до `string`.

[⬆ Back to Top](#typescript-введение-в-типизацию)

[⬆ Back to Top](#typescript-введение-в-типизацию)

## Дженерики (Generic)

> Дженерики играют решающую роль в программировании, поскольку они позволяют создавать типобезопасные функции без предварительного указания точного типа, но допускают ограничения и проверки типов программиста.

Generics (дженерики) обеспечивают возможность создавать функции, классы, интерфейсы и типы на основе параметров обобщенных типов (параметр типа).

Обобщенный тип данных (generic type) - это обобщенная функция, класс, интерфейс и т. д., параметризованный по одному или нескольким типам.

Основное назначение дженериков заключается в том, чтобы обеспечить возможность работы с абстрактными типами данных внутри классов, функций и интерфейсов.
Они позволяют создавать и использовать компоненты, которые могут работать с различными типами данных, сохраняя при этом информацию о типах при компиляции.

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Generic Type Variables (параметры типа)

В качестве примера рассмотрим функцию идентификации, которая принимает определенный аргумент и возвращает его же:

```ts
function identity(arg: number): number {
  return arg;
}
```

Или функцию можно было бы описать используя тип `any`:

```ts
function identity(arg: any): any {
  return arg;
}
```

Безусловно использование `any` является универсальным способом, поскольку позволяет передавать аргументы люболго типа в функцию, но в этом случае информация о типе теряется и единственная информация о типе, которая будет известна, это то, что может быть возвращен любой тип.

Вместо использования `any` нам нужен другой способ, позволяющий зафиксировать тип передаваемого аргумента, который можно так же использовать для обозначения типа возвращаемого значения.

Для этого можно использовать _переменную типа_ (параметр типа), особый вид переменной, которая работает с типами, а не со значениями:

```ts
function identity<T>(arg: T): T {
  return arg;
}
```

В этом примере функция `identity` использует параметр типа `<T>`, чтобы принимать аргумент любого типа `T` и возвращать значение того же типа `T`.
При вызове функции с разными типами данных (например, строкой и числом), тип возвращаемого значения соответствует переданному типу данных.

Теперь функцию `identity` можно вызвать несколькими способами:

1. Указав явно тип при вызове функции:
    ```ts
    const result1 = identity<string>('hello'); // result1 имеет тип string
    const result2 = identity<number>(123); // result2 имеет тип number
    ```
2. TypeScript также может вывести тип автоматически на основе переданных аргументов, поэтому можно вызвать функцию без явного указания типа:
    ```ts
    let result3 = identity('hello'); // result3 имеет тип string
    let result4 = identity(123); // result4 имеет тип number
    ```

Рассмотрим функции фильтрации массива с использованием дженерика:

```ts
function filterArray<T>(array: T[], predicate: (item: T) => boolean): T[] {
  return array.filter(item => predicate(item));
}

// Функция для фильтрации чисел больше 3
function isGreaterThan3(n: number): boolean {
  return n > 3;
}

let numbers = [1, 2, 3, 4, 5];
let filteredNumbers = filterArray(numbers, isGreaterThan3); // filteredNumbers имеет тип number[]

// Функция для фильтрации строк, начинающихся с "A"
function startsWithA(s: string): boolean {
  return s.startsWith('A');
}

let names = ['Alice', 'Bob', 'Charlie', 'Amy'];
let filteredNames = filterArray(names, startsWithA); // filteredNames имеет тип string[]
```

В этом примере функция `filterArray` принимает массив любого типа `T` и предикат (функцию), которая определяет, какие элементы должны быть возвращены. Внутри функции `filterArray` типизация `T` применяется к массиву и предикату, что позволяет обеспечить безопасность типов внутри функции.

При вызове `filterArray` с массивом чисел `numbers` и предикатом `isGreaterThan3`, типизация `T` выводится как `number`, а при вызове с массивом строк `names` и предикатом `startsWithA`, типизация `T` выводится как `string`. Это позволяет использовать одну и ту же функцию для различных типов данных и предикатов, сохраняя информацию о типах во время компиляции.

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Обобщённые типы (Generic Types)

Обобщённые типы (Generic Types) в TypeScript представляют собой абстракции, которые могут работать с различными типами данных. Они позволяют создавать универсальные типы, которые обеспечивают безопасность типов во время компиляции и повышают переиспользование кода.

Для создания обобщённых типов используются дженерики, которые параметризуют типы. Обобщённые типы могут быть использованы для определения типов функций, объектов, классов и других конструкций.

Пример универсального интерфейса на основе дженерика:

```ts
// Универсальный интерфейс
interface Pair<T, U> {
  first: T;
  second: U;
}

// Использование универсального интерфейса
let pair1: Pair<string, number> = { first: "one", second: 1 };
```

Универсальный интерфейс `Pair<T, U>` определяет пару значений, где `first` и `second` могут быть разных типов `T` и `U`.
Переменная `pair1` использует обобщенный интерфейс `Pair<string, number>` для определения пары значений с типами `string` и `number`.

Пример универсального класса на основе дженерика:

```ts
// Универсальный класс
class KeyValuePair<T, U> {
  first: T;
  second: U;
  
  constructor(first: T, second: U) {
    this.first = first;
    this.second = second;
  }
}

// Использование универсального класса
let pair2 = new KeyValuePair<number, boolean>(5, true);
```

Универсальный класс `KeyValuePair<T, U>` представляет пару ключ-значение, где `key` и `value` могут быть разных типов `T` и `U`.

Переменная `pair2` создает экземпляр обобщенного класса `KeyValuePair<number, boolean>` для хранения пары числа и булевого значения.

Пример универсального типа на основе дженерика:

```ts
type Box<T> = {
  value: T;
};

const numberBox: Box<number> = { value: 123 };
const listBox: Box<string[]> = { value: ['apple', 'banana', 'cherry'] };
```

В этом примере, тип `Box<T>` является обобщённым, так как он параметризован типом `T`. При создании переменных `numberBox` и `listBox` указываются конкретные типы `number` и `string[]`, соответственно.

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Ограничение типов в дженериках (Generic Constraints)

Как и в интерфейсах, в дженериках, TypeScript позволяет ограничить типы, используя ключевое слово `extends`.
Это позволяет более точно указать, какие типы данных могут быть использованы в обобщённых конструкциях.

```ts
interface Lengthwise {
  length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
  console.log(arg.length);
  
  return arg;
}

loggingIdentity({ length: 5, value: "hello" }); // Вывод: 5
```

В этом примере, функция `loggingIdentity` принимает обобщённый аргумент `T`, который ограничен типом `Lengthwise`.
Это означает, что аргумент, передаваемый в функцию, должен иметь свойство `length` типа `number`.

При вызове `loggingIdentity({ length: 5, value: "hello" })`, аргумент удовлетворяет ограничению, потому что он имеет свойство `length` типа `number`.
Функция выводит значение свойства `length` и возвращает аргумент.

[⬆ Back to Top](#typescript-введение-в-типизацию)

### Правила использования дженериков

Дженерики подчиняются следующим правилам в TypeScript:

- Обобщенный тип определяется с помощью параметра типа, заключенного в угловые скобки `<...>`. Например, `Array<T>`, где `T` - параметр типа.
  ```ts
  function identity<T>(arg: T): T {
    return arg;
  }
  ```
- Параметр типа может иметь любое имя, чаще всего используются однобуквенные или описательные имена, например `T`, `K`, `V` и т. д.
  ```ts
  interface KeyValuePair<K, V> {
    key: K;
    value: V;
  }
  ```
- Параметр типа может быть использован в объявлениях аргументов функций, типах свойств классов и интерфейсов, а также возвращаемых значениях функций.
  ```ts
  function toArray<T>(arg: T): T[] {
    return [arg];
  }
  
  let array: number[] = toArray<number>(42);
  ```
- При вызове функции с обобщенным типом, TypeScript автоматически выведет тип на основе переданных аргументов.
  ```ts
  const array = toArray(42); // array имеет тип number[]
  ```
- Параметр типа может быть ограничен определенным типом, используя ключевое слово `extends`. Например, `function<T extends SomeType>(...)`, где `SomeType` - ограничение для параметра типа.
  ```ts
  interface Printable {
    print(): void;
  }
  
  class Book implements Printable {
    print() {
      console.log('Printing a book');
    }
  }
  
  class Magazine implements Printable {
    print() {
      console.log('Printing a magazine');
    }
  }
  
  function printItems<T extends Printable>(items: T[]) {
    for (const item of items) {
      item.print();
    }
  }
  
  const books = [new Book(), new Book()];
  const magazines = [new Magazine(), new Magazine()];
  
  printItems(books); // Выводит "Printing a book' два раза
  printItems(magazines); // Выводит "Printing a magazine" два раза
  ```
- Внутри обобщенного типа  можно использовать параметр типа для работы с переданными значениями и возвращаемыми значениями, сохраняя информацию о типах при компиляции.
  ```ts
  class SomeClass<T> {
    private value: T;
  
    constructor(initialValue: T) {
      this.value = initialValue;
    }
  
    getValue(): T {
      return this.value;
    }
  
    setValue(newValue: T): void {
      this.value = newValue;
    }
  }
  ```

[⬆ Back to Top](#typescript-введение-в-типизацию)

## Оператор типа Keyof

Оператор `keyof` тип, который представляет все возможные ключи объекта.
Он полезен для работы с типами и обобщения кода, когда нужно обращаться к ключам объекта без конкретизации их значений.

В следующем примере определяем тип `P` того же типа, что и `type P = "x" | "y"`:

```ts
type Point = { x: number; y: number };
type P = keyof Point; // type P = keyof Point
```

Еще один пример использования оператора `keyof`:

```ts
interface Person {
  name: string;
  age: number;
  address: string;
}

type PersonKeys = keyof Person;
// Тип PersonKeys равен "name" | "age" | "address"

function getProperty(obj: Person, key: keyof Person) {
  return obj[key];
}

const person: Person = { name: 'Alice', age: 30, address: '123 Main St' };

const name = getProperty(person, 'name'); // Тип name равен string
const age = getProperty(person, 'age'); // Тип age равен number
const address = getProperty(person, 'address'); // Тип address равен string
```

В этом примере оператор `keyof` используется для определения типа `PersonKeys`, который представляет все возможные ключи объекта `Person`.
Затем функция getProperty использует `keyof Person` в качестве типа для аргумента `key`, чтобы обратиться к свойствам объекта `Person` без конкретизации их значений.

Пример использования оператора `keyof` с сигнатурой индекса:

```ts
type Arrayish = { [n: number]: unknown };
type A = keyof Arrayish; // type A = number


type Mapish = { [k: string]: boolean };
type M = keyof Mapish; // type M = string | number
```

Обратите внимание, что в этом примере `M` является `string | number` - это потому, что ключи объекта JavaScript всегда приводятся к строке, поэтому `obj[0]` всегда то же самое, что и `obj["0"]`.

[⬆ Back to Top](#typescript-введение-в-типизацию)

## Оператор типа Typeof

Оператор `typeof` в TypeScript используется для получения типа данных переменной, свойства или выражения во время компиляции.
Это позволяет выполнять проверки типов и использовать информацию о типах во время разработки.

Оператор `typeof` может быть использован в контексте выражения:

```ts
// Выведет "string"
console.log(typeof "Hello world");
```

Оператор `typeof` так же можно использовать в _контексте типа_ для ссылки на _тип_ переменной или свойства:

```ts
let s = "hello";
let n: typeof s; // let n: string
```

Проверка типа данных при использовании переменной:

```ts
function printType(value: any) {
  if (typeof value === 'number') {
    console.log('Value is a number');
  } else if (typeof value === 'string') {
    console.log('Value is a string');
  } else {
    console.log('Value is of a different type');
  }
}

printType(10); // Output: Value is a number
printType('hello'); // Output: Value is a string
printType(true); // Output: Value is of a different type
```

В этом примере:

- Функция `printType` принимает параметр `value` с типом `any`.
- Мы используем оператор `typeof` для проверки типа данных переменной `value`.
- В зависимости от результата проверки типа выводится соответствующее сообщение.

Получение типа свойства объекта:

```ts
interface Person {
  name: string;
  age: number;
}

const person = {
  name: 'Alice',
  age: 30
};

let propertyName: keyof Person = 'name';
let propertyType: string = typeof person[propertyName];
```

В этом примере:

- Интерфейс `Person` описывает структуру объекта, в котором есть свойство `name` и свойство `age`.
- Оператор `keyof` используется для получения типа всех ключей интерфейса `Person`.
- Выбирается конкретный ключ `name` и сохраняется в переменную `propertyName`.
- Оператор `typeof` используется для получения типа значения свойства `name` из объекта `person` и сохраняем его в переменную `propertyType`.

Пример использования оператора `typeof` в дженериках:

```ts
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

let person = { name: 'Alice', age: 30 };
let name: string = getProperty(person, 'name');
let age: number = getProperty(person, 'age');
```

В этом примере:

- Функция `getProperty`принимает два обобщённых типа `T` и `K`.
- Параметр `obj` имеет тип `T`, который представляет объект, а параметр `key` имеет тип `K`, который представляет ключ объекта `T`.
- Далее используется ограничение `K extends keyof T` для того, чтобы убедиться, что тип `K` является ключом объекта `T`.
- Функция возвращает значение по указанному ключу из объекта `T` с помощью выражения `obj[key]`.


Пример использования оператора `typeof` c `ReturnType`:

```ts
function greet(): string {
  return 'Hello';
}

type Greeting = ReturnType<typeof greet>; // Greeting будет иметь тип string
```

Оператор `ReturnType` используется для извлечения типа возвращаемого значения функции. Это позволяет нам получить тип данных, который будет возвращен при вызове функции.

[⬆ Back to Top](#typescript-введение-в-типизацию)

## Примеси (Mixin)

Примеси (mixin) в TypeScript представляют собой способ добавления поведения к классам, путем объединения их с другими классами. Они позволяют переиспользовать код и достичь композиции, не наследуя от классов.

[⬆ Back to Top](#typescript-введение-в-типизацию)

## Декораторы (Decorators)

Декораторы - это конструкция, которая позволяет добавлять новые функциональные возможности к классам, функциям или методам.

[⬆ Back to Top](#typescript-введение-в-типизацию)


Ссылки на материалы:

- [Глубокое погружение в TypeScript](https://typescript-book-ru.netlify.app)
- [The TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/intro.html)
- Бесплатный тренинг от Microsoft: [Создание приложений JavaScript с помощью TypeScript](https://learn.microsoft.com/ru-ru/training/paths/build-javascript-applications-typescript/)
- Курс от code-basics.com: [TypeScript бесплатное обучение для разработчиков](https://code-basics.com/ru/languages/typescript)

> Coming soon...
